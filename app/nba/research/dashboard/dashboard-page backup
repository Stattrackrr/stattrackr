"use client";

import React, { useEffect, useMemo, useState, useCallback, useRef } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import Navigation from "@/components/navigation";
import { ArrowLeft, Search, BarChart3, Activity, TrendingUp, TrendingDown, Calendar, Clock } from "lucide-react";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, ResponsiveContainer, ReferenceLine, Cell, Tooltip, LabelList } from 'recharts';
import { ESPN_NBA_ROSTERS_CURRENT, NBA_TEAM_NAMES } from "@/lib/espnNbaRostersCurrent";
import { PlayerLineMovement, TeamMatchupOdds, GameTotalOdds, BookmakerComparison } from "@/components/OddsDisplay";

// Error Boundary Component
class ErrorBoundary extends React.Component<
  { children: React.ReactNode; fallback?: React.ComponentType<{error: Error; reset: () => void}> },
  { hasError: boolean; error: Error | null }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Dashboard Error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      const Fallback = this.props.fallback || DefaultErrorFallback;
      return <Fallback error={this.state.error!} reset={() => this.setState({ hasError: false, error: null })} />;
    }
    return this.props.children;
  }
}

const DefaultErrorFallback: React.FC<{error: Error; reset: () => void}> = ({ error, reset }) => (
  <div className="min-h-screen bg-slate-900 text-white flex items-center justify-center">
    <div className="text-center p-8 max-w-lg">
      <div className="text-red-500 text-6xl mb-4">‚ö†Ô∏è</div>
      <h2 className="text-2xl font-bold mb-4">Dashboard Error</h2>
      <p className="text-slate-300 mb-4">Something went wrong loading the analytics dashboard.</p>
      <details className="mb-4">
        <summary className="text-sm text-slate-400 cursor-pointer mb-2">Technical Details</summary>
        <pre className="text-xs text-red-400 bg-slate-800 p-2 rounded overflow-auto max-h-32">
          {error.message}
        </pre>
      </details>
      <button 
        onClick={reset}
        className="bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded font-medium transition-colors"
      >
        Try Again
      </button>
    </div>
  </div>
);

/* Types */
interface NBAGame {
  id: number;
  date: string;
  status: string;
  home_team: {
    id: number;
    abbreviation: string;
    full_name: string;
  };
  visitor_team: {
    id: number;
    abbreviation: string;
    full_name: string;
  };
  home_team_score: number;
  visitor_team_score: number;
}

type PlayerGameRow = {
  id?: number;
  game: {
    id: number;
    date: string; // ISO in UTC from BallDontLie
    season: number; // 2024 for 2024/25 season
    postseason: boolean;
    home_team?: { abbreviation: string };
    visitor_team?: { abbreviation: string };
  };
  team?: { abbreviation?: string };
  pts?: number;
  reb?: number;
  ast?: number;
  stl?: number;
  blk?: number;
  turnover?: number;
  fgm?: number;
  fga?: number;
  fg_pct?: number;
  fg3m?: number;
  fg3a?: number;
  fg3_pct?: number;
  ftm?: number;
  fta?: number;
  ft_pct?: number;
  oreb?: number;
  dreb?: number;
  pf?: number;
  min?: string | number;
};

/* Robust EST/EDT time helpers */
// Build a stable millisecond timestamp for America/New_York without re-parsing a locale string.
function toESTMillis(iso: string): number {
  const d = new Date(iso);
  const fmt = new Intl.DateTimeFormat("en-US", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });
  const parts = fmt.formatToParts(d).reduce<Record<string, string>>((acc, p) => {
    if (p.type !== "literal") acc[p.type] = p.value;
    return acc;
  }, {});
  const year = Number(parts.year);
  const month = Number(parts.month);   // 1-12
  const day = Number(parts.day);
  const hour = Number(parts.hour);
  const minute = Number(parts.minute);
  const second = Number(parts.second);
  // Construct a UTC timestamp from the NY-local wall time so comparisons are correct.
  return Date.UTC(year, month - 1, day, hour, minute, second);
}

// Short label like "Apr 30, 2025" in NY time
function formatEST(iso: string): string {
  return new Date(iso).toLocaleDateString("en-US", {
    timeZone: "America/New_York",
    month: "short",
    day: "numeric",
    year: "numeric",
  });
}

/* Data validation helpers */
const isValidNumber = (value: any): boolean => {
  return typeof value === 'number' && !isNaN(value) && isFinite(value);
};

const safeNumber = (value: any, fallback: number = 0): number => {
  if (isValidNumber(value)) return value;
  if (typeof value === 'string') {
    const parsed = parseFloat(value);
    return isValidNumber(parsed) ? parsed : fallback;
  }
  return fallback;
};

const safePercentage = (value: any): number => {
  const num = safeNumber(value);
  // Clamp percentages between 0 and 1 (API format)
  return Math.max(0, Math.min(1, num));
};

/* Stat mapping helper */
const pickStat = (row: any, stat: string): number => {
  if (!row) return 0;
  
  switch (stat) {
    case "points":
      return safeNumber(row.pts);
    case "rebounds":
      return safeNumber(row.reb);
    case "assists":
      return safeNumber(row.ast);
    case "steals":
      return safeNumber(row.stl);
    case "blocks":
      return safeNumber(row.blk);
    case "turnovers":
      return safeNumber(row.turnover);
    case "fgm":
      return safeNumber(row.fgm);
    case "fga":
      return safeNumber(row.fga);
    case "fg_pct":
      return safePercentage(row.fg_pct);
    case "fg3m":
      return safeNumber(row.fg3m);
    case "fg3a":
      return safeNumber(row.fg3a);
    case "fg3_pct":
      return safePercentage(row.fg3_pct);
    case "ftm":
      return safeNumber(row.ftm);
    case "fta":
      return safeNumber(row.fta);
    case "ft_pct":
      return safePercentage(row.ft_pct);
    case "oreb":
      return safeNumber(row.oreb);
    case "dreb":
      return safeNumber(row.dreb);
    case "pf":
      return safeNumber(row.pf);
    case "min":
      // Handle minutes which can be in "MM:SS" format or just a number
      const minutes = row.min;
      if (typeof minutes === 'string' && minutes.includes(':')) {
        const [min, sec] = minutes.split(':');
        const minNum = safeNumber(min);
        const secNum = safeNumber(sec);
        return minNum + (secNum / 60);
      }
      return safeNumber(minutes);
    default:
      return 0;
  }
};

/* Data normalization helpers */
function normalizeAndSort(
  rows: PlayerGameRow[],
  opts: { season?: number; includePlayoffs?: boolean } = {}
) {
  const { season, includePlayoffs = false } = opts;
  const seen = new Set<number>();

  const filtered = rows.filter((r) => {
    const okSeason = season == null || r.game.season === season;
    const okPost = includePlayoffs ? true : !r.game.postseason;
    return okSeason && okPost;
  });

  const deduped = filtered.filter((r) => {
    if (seen.has(r.game.id)) return false;
    seen.add(r.game.id);
    return true;
  });

  // *** CRITICAL: sort by EST/EDT wall-clock time (oldest to newest) ***
  deduped.sort((a, b) => toESTMillis(a.game.date) - toESTMillis(b.game.date));
  return deduped;
}

/* BallDontLie fetch helpers with improved error handling */
const playerIdCache = new Map<string, number>();
const failedLookupCache = new Set<string>();

// Rate limiting helpers
const rateLimitDelay = (attempt: number) => {
  const delays = [0, 1000, 2000, 5000, 10000]; // Progressive backoff
  return delays[Math.min(attempt, delays.length - 1)];
};

const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

async function fetchWithRetry(url: string, maxRetries = 3): Promise<any> {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      if (attempt > 0) {
        await sleep(rateLimitDelay(attempt));
        console.log(`Retry attempt ${attempt} for ${url}`);
      }
      
      const response = await fetch(url);
      
      if (response.status === 429) {
        // Rate limited - wait longer
        const retryAfter = response.headers.get('Retry-After');
        const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : rateLimitDelay(attempt + 1);
        console.log(`Rate limited, waiting ${waitTime}ms`);
        await sleep(waitTime);
        continue;
      }
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      return data;
      
    } catch (error) {
      console.error(`Attempt ${attempt + 1} failed:`, error);
      if (attempt === maxRetries) {
        throw error;
      }
    }
  }
}

async function fetchBDLPlayerIdByName(name: string): Promise<number | null> {
  if (playerIdCache.has(name)) {
    console.log(`Using cached player ID for ${name}:`, playerIdCache.get(name)!);
    return playerIdCache.get(name)!;
  }
  
  if (failedLookupCache.has(name)) {
    console.log(`Skipping failed lookup for ${name}`);
    return null;
  }
  
  try {
    console.log(`√∞≈∏‚Äù¬ç Searching for player: "${name}"`);
    
    // Handle common name variations and nicknames
    const getNameVariations = (fullName: string): string[] => {
      const variations = [fullName];
      
      // Common name fixes
      const fixes: { [key: string]: string[] } = {
        'Brandin Podziemski': ['Brandin Podziemski', 'Podziemski', 'Brandin'],
        'Stephen Curry': ['Stephen Curry', 'Steph Curry', 'Curry', 'Stephen', 'Steph'],
        'Alperen Sengun': ['Alperen Sengun', 'Alperen √Ö≈æeng√É¬ºn', 'Sengun'],
        'Nikola Jokic': ['Nikola Jokic', 'Nikola Joki√Ñ‚Ä°'],
        'Luka Doncic': ['Luka Doncic', 'Luka Don√Ñ¬çi√Ñ‚Ä°'],
        'Bogdan Bogdanovic': ['Bogdan Bogdanovic', 'Bogdan Bogdanovi√Ñ‚Ä°'],
        'Giannis Antetokounmpo': ['Giannis Antetokounmpo', 'Giannis', 'Antetokounmpo'],
        'Victor Wembanyama': ['Victor Wembanyama', 'Wembanyama', 'Victor'],
      };
      
      // Check for exact match in fixes
      if (fixes[fullName]) {
        variations.push(...fixes[fullName]);
      }
      
      // Add standard variations
      const parts = fullName.split(' ');
      if (parts.length >= 2) {
        variations.push(parts[0]); // First name
        variations.push(parts[parts.length - 1]); // Last name
        
        // Handle Jr., Sr., III, etc.
        if (parts.length > 2) {
          variations.push(`${parts[0]} ${parts[1]}`); // First two names
        }
      }
      
      return [...new Set(variations)]; // Remove duplicates
    };
    
    // Try multiple search strategies with name variations
    const allVariations = getNameVariations(name);
    console.log(`√∞≈∏‚Äù‚Ç¨ Trying name variations:`, allVariations);
    
    const searchStrategies = allVariations;
    
    for (const searchTerm of searchStrategies) {
      const url = `/api/balldontlie?endpoint=/players&search=${encodeURIComponent(searchTerm)}&per_page=100`;
      console.log(`üéØ Trying search term: "${searchTerm}"`);
      console.log('API URL:', url);
      
      try {
        const data = await fetchWithRetry(url);
        
        if (data.error) {
          console.error(`API Error for "${searchTerm}":`, data.error);
          continue;
        }
        
        const list = Array.isArray(data?.data) ? data.data : [];
        console.log(`üìã Found ${list.length} players for "${searchTerm}":`);
      
      // Log all found players for debugging
      list.forEach((p: any, i: number) => {
        console.log(`  ${i + 1}. ${p.first_name} ${p.last_name} (ID: ${p.id}, Team: ${p.team?.abbreviation || 'N/A'})`);
      });
      
      const targetLower = name.toLowerCase();
      const nameParts = targetLower.split(' ');
      
      // Try different matching strategies
      const matchingStrategies = [
        // 1. Exact match
        (p: any) => `${p.first_name} ${p.last_name}`.toLowerCase() === targetLower,
        
        // 2. Fuzzy match (handles common variations)
        (p: any) => {
          const fullName = `${p.first_name} ${p.last_name}`.toLowerCase();
          return nameParts.every(part => fullName.includes(part));
        },
        
        // 3. Last name exact + first name starts with
        (p: any) => {
          const lastName = p.last_name.toLowerCase();
          const firstName = p.first_name.toLowerCase();
          return lastName === nameParts[nameParts.length - 1] && 
                 firstName.startsWith(nameParts[0]);
        },
        
        // 4. First name exact + last name starts with
        (p: any) => {
          const lastName = p.last_name.toLowerCase();
          const firstName = p.first_name.toLowerCase();
          return firstName === nameParts[0] && 
                 lastName.startsWith(nameParts[nameParts.length - 1]);
        }
      ];
      
      for (const [index, strategy] of matchingStrategies.entries()) {
        const best = list.find(strategy);
        if (best?.id) {
          console.log(`‚úÖ Match found using strategy ${index + 1}: ${best.first_name} ${best.last_name} (ID: ${best.id})`);
          playerIdCache.set(name, best.id);
          return best.id;
        }
      }
      
      } catch (searchError) {
        console.error(`Search failed for "${searchTerm}":`, searchError);
        continue;
      }
    }
    
    console.log(`‚ùå No player found for: "${name}" after trying all strategies`);
    failedLookupCache.add(name); // Cache failed lookups to avoid retries
    return null;
  } catch (error) {
    console.error('Error fetching player ID:', error);
    failedLookupCache.add(name);
    return null;
  }
}

async function fetchPlayerGameLogs(
  playerId: number,
  seasons: number[]
): Promise<PlayerGameRow[]> {
  console.log(`Fetching game logs for player ID ${playerId}, seasons:`, seasons);
  const rows: PlayerGameRow[] = [];
  
  for (const season of seasons) {
    console.log(`Fetching season ${season} for player ${playerId}`);
    
    for (let page = 1; page <= 5; page++) {
      const url = `/api/balldontlie?endpoint=/stats&player_ids[]=${playerId}&seasons[]=${season}&per_page=100&page=${page}`;
      console.log(`Fetching page ${page}:`, url);
      
      try {
        const data = await fetchWithRetry(url);
        
        console.log(`Page ${page} response:`, data);
        
        if (data.error) {
          console.error(`API Error on page ${page}:`, data.error);
          break;
        }
        
        const chunk: PlayerGameRow[] = Array.isArray(data?.data) ? data.data : [];
        console.log(`Page ${page} returned ${chunk.length} games`);
        
        if (!chunk.length) {
          console.log(`No more data on page ${page}, stopping`);
          break;
        }
        
        rows.push(...chunk);
        
        if (chunk.length < 100) {
          console.log(`Less than 100 results on page ${page}, last page reached`);
          break;
        }
      } catch (error) {
        console.error(`Error fetching page ${page}:`, error);
        break;
      }
    }
  }
  
  console.log(`Total games fetched for player ${playerId}:`, rows.length);
  return rows;
}

// Advanced stats type for BallDontLie GOAT plan
interface AdvancedStats {
  usage_percentage?: number;
  true_shooting_percentage?: number;
  offensive_rating?: number;
  pace?: number;
  assist_percentage?: number;
  effective_field_goal_percentage?: number;
  defensive_rating?: number;
  defensive_rebound_percentage?: number;
  rebound_percentage?: number;
  
  // Additional BallDontLie metrics
  player_efficiency_rating?: number; // PIE
  assist_to_turnover_ratio?: number;
  turnover_ratio?: number;
  net_rating?: number;
}

// Helper functions to calculate advanced stats from basic stats
function calculateTrueShootingPercentage(stats: any): number {
  const pts = stats.pts || 0;
  const fga = stats.fga || 0;
  const fta = stats.fta || 0;
  
  if (fga === 0 && fta === 0) return 0;
  
  // True Shooting % = PTS / (2 * (FGA + 0.44 * FTA))
  const tsAttempts = 2 * (fga + (0.44 * fta));
  return tsAttempts > 0 ? pts / tsAttempts : 0;
}

function calculateEffectiveFGPercentage(stats: any): number {
  const fgm = stats.fgm || 0;
  const fga = stats.fga || 0;
  const fg3m = stats.fg3m || 0;
  
  if (fga === 0) return 0;
  
  // Effective FG% = (FGM + 0.5 * 3PM) / FGA
  return (fgm + (0.5 * fg3m)) / fga;
}

// Calculate Player Efficiency Rating (PER) - simplified version without league averages
function calculatePER(stats: any): number {
  const pts = stats.pts || 0;
  const ast = stats.ast || 0;
  const reb = stats.reb || 0;
  const stl = stats.stl || 0;
  const blk = stats.blk || 0;
  const fgm = stats.fgm || 0;
  const fga = stats.fga || 0;
  const ftm = stats.ftm || 0;
  const fta = stats.fta || 0;
  const turnover = stats.turnover || 0;
  const pf = stats.pf || 0;
  
  // Try different possible minute field names
  const min = stats.min || stats.minutes || stats.mins || 0;
  
  console.log('PER calculation inputs:', { pts, ast, reb, stl, blk, fgm, fga, ftm, fta, turnover, pf, min });
  
  // If no minutes data, calculate PER based on per-game stats (assume reasonable minutes)
  if (min <= 0) {
    // Use a simplified PER calculation without minutes scaling
    const simplePER = (
      pts + 
      (0.4 * fgm) + 
      (0.7 * ast) + 
      (0.3 * reb) + 
      stl + 
      (0.7 * blk) - 
      (0.4 * (fga - fgm)) - 
      (0.4 * (fta - ftm)) - 
      turnover - 
      (0.4 * pf)
    );
    
    console.log('Calculated simple PER (no minutes):', simplePER);
    return Math.max(0, simplePER);
  }
  
  // Standard PER calculation with minutes scaling
  const factor = 36 / min;
  const uPER = factor * (
    pts + 
    (0.4 * fgm) + 
    (0.7 * ast) + 
    (0.3 * reb) + 
    stl + 
    (0.7 * blk) - 
    (0.4 * (fga - fgm)) - 
    (0.4 * (fta - ftm)) - 
    turnover - 
    (0.4 * pf)
  );
  
  console.log('Calculated PER with minutes:', uPER);
  return Math.max(0, uPER);
}

// Calculate Assist-to-Turnover Ratio
function calculateAssistToTurnoverRatio(stats: any): number {
  const ast = stats.ast || 0;
  const turnover = stats.turnover || 0;
  
  if (turnover === 0) return ast > 0 ? 999 : 0; // Perfect ratio if no turnovers but has assists
  return ast / turnover;
}

// Calculate Steal-to-Foul Ratio
function calculateStealToFoulRatio(stats: any): number {
  const stl = stats.stl || 0;
  const pf = stats.pf || 0;
  
  if (pf === 0) return stl > 0 ? 999 : 0; // Perfect ratio if no fouls but has steals
  return stl / pf;
}

// Calculate Points Per Shot
function calculatePointsPerShot(stats: any): number {
  const pts = stats.pts || 0;
  const fga = stats.fga || 0;
  const fta = stats.fta || 0;
  
  const totalShots = fga + (0.44 * fta); // Include free throw attempts as "shots"
  if (totalShots === 0) return 0;
  
  return pts / totalShots;
}

// Fetch advanced stats from BallDontLie GOAT plan
async function fetchPlayerAdvancedStats(
  playerId: number,
  season: number
): Promise<AdvancedStats | null> {
  try {
    console.log(`√∞≈∏¬è‚Ç¨ Fetching REAL NBA advanced stats for player ${playerId}, season ${season}`);
    console.log(`√∞≈∏‚Äú‚Ä¶ Season ${season} = NBA ${season}-${season+1} season (e.g. 2024 = 2024-25 season)`);
    console.log(`√¢≈ì‚Ä¶ This is LIVE DATA from BallDontLie API, not mock data`);
    
    // BallDontLie GOAT plan advanced stats - use correct endpoint from documentation
    console.log('√∞≈∏≈Ω¬Ø Attempting to fetch advanced stats...');
    
    // Method 1: Use the correct /stats/advanced endpoint with player_ids array
    let advancedUrl = `/api/balldontlie?endpoint=/stats/advanced&player_ids[]=${playerId}&seasons[]=${season}`;
    console.log('√∞≈∏‚Äú≈† Method 1 URL:', advancedUrl);
    
    let res = await fetch(advancedUrl);
    let data = await res.json();
    
    console.log('√∞≈∏‚Äù¬ç Method 1 Response:', JSON.stringify(data, null, 2));
    
    // Method 2: If that fails, try with postseason parameter
    if (data.error || !data.data || data.data.length === 0) {
      console.log('√∞≈∏‚Äù‚Äû Method 1 failed, trying Method 2...');
      advancedUrl = `/api/balldontlie?endpoint=/stats/advanced&player_ids[]=${playerId}&seasons[]=${season}&postseason=false`;
      console.log('√∞≈∏‚Äú≈† Method 2 URL:', advancedUrl);
      
      res = await fetch(advancedUrl);
      data = await res.json();
      console.log('√∞≈∏‚Äù¬ç Method 2 Response:', JSON.stringify(data, null, 2));
    }
    
    // Method 3: Try season_averages as fallback (if stats/advanced doesn't work)
    if (data.error || !data.data || data.data.length === 0) {
      console.log('√∞≈∏‚Äù‚Äû Method 2 failed, trying Method 3 (season_averages)...');
      advancedUrl = `/api/balldontlie?endpoint=/season_averages&player_id=${playerId}&season=${season}`;
      console.log('√∞≈∏‚Äú≈† Method 3 URL:', advancedUrl);
      
      res = await fetch(advancedUrl);
      data = await res.json();
      console.log('√∞≈∏‚Äù¬ç Method 3 Response:', JSON.stringify(data, null, 2));
    }
    
    console.log('√∞≈∏‚Äù¬ç Advanced stats RAW response:', JSON.stringify(data, null, 2));
    
    if (data.error) {
      console.error('Advanced stats API Error:', data.error);
      return null;
    }
    
    const statsArray = Array.isArray(data?.data) ? data.data : [];
    console.log('√∞≈∏‚Äú≈† Advanced stats array length:', statsArray.length);
    
    if (statsArray.length === 0) {
      console.log('√¢¬ù≈í No advanced stats data available');
      return null;
    }
    
    const stats = statsArray[0]; // Get first (and likely only) result
    console.log('√∞≈∏‚ÄúÀÜ Parsed advanced stats object:', JSON.stringify(stats, null, 2));
    console.log('√∞≈∏≈Ω¬Ø Available keys in stats:', Object.keys(stats));
    
    // Log individual stat values for debugging
    console.log('√∞≈∏‚Äô¬° Individual stat values:');
    console.log('  - usage_percentage:', stats.usage_percentage);
    console.log('  - true_shooting_percentage:', stats.true_shooting_percentage);
    console.log('  - offensive_rating:', stats.offensive_rating);
    console.log('  - pace:', stats.pace);
    console.log('  - assist_percentage:', stats.assist_percentage);
    console.log('  - effective_field_goal_percentage:', stats.effective_field_goal_percentage);
    console.log('  - defensive_rating:', stats.defensive_rating);
    console.log('  - defensive_rebound_percentage:', stats.defensive_rebound_percentage);
    console.log('  - rebound_percentage:', stats.rebound_percentage);
    
    // Show only BallDontLie's provided advanced stats - no calculations
    console.log('√∞≈∏‚Äú≈† REAL NBA DATA from BallDontLie API:');
    console.log('√∞≈∏≈Ω¬Ø Player ID:', playerId, '| Season:', season, '(NBA', season + '-' + (season + 1), 'season)');
    console.log('√∞≈∏‚ÄúÀÜ Raw BallDontLie response:', JSON.stringify(stats, null, 2));
    console.log('√¢≈ì‚Ä¶ This data comes directly from BallDontLie\'s database of real NBA games');
    
    // Verify this is real data by checking if we have actual stat values
    const hasRealData = stats.pts || stats.ast || stats.reb || stats.fgm;
    console.log('√∞≈∏‚Äù¬ç Data verification - Has real stats:', hasRealData ? '√¢≈ì‚Ä¶ YES' : '√¢¬ù≈í NO');
    
    const calculatedStats = {
      // Use ONLY BallDontLie's provided advanced stats (GOAT plan) - no fallbacks
      usage_percentage: stats.usage_percentage, // √¢≈ì‚Ä¶ Provided by BallDontLie GOAT plan
      true_shooting_percentage: stats.true_shooting_percentage, // √¢≈ì‚Ä¶ Provided by BallDontLie GOAT plan
      offensive_rating: stats.offensive_rating, // √¢≈ì‚Ä¶ Provided by BallDontLie GOAT plan
      pace: stats.pace, // √¢≈ì‚Ä¶ Provided by BallDontLie GOAT plan
      assist_percentage: stats.assist_percentage, // √¢≈ì‚Ä¶ Provided by BallDontLie GOAT plan
      effective_field_goal_percentage: stats.effective_field_goal_percentage, // √¢≈ì‚Ä¶ Provided by BallDontLie GOAT plan
      defensive_rating: stats.defensive_rating, // √¢≈ì‚Ä¶ Provided by BallDontLie GOAT plan
      defensive_rebound_percentage: stats.defensive_rebound_percentage, // √¢≈ì‚Ä¶ Provided by BallDontLie GOAT plan
      rebound_percentage: stats.rebound_percentage, // √¢≈ì‚Ä¶ Provided by BallDontLie GOAT plan
      
      // Additional stats from BallDontLie (if available)
      player_efficiency_rating: stats.pie, // PIE (Player Impact Estimate) from BallDontLie
      assist_to_turnover_ratio: stats.assist_to_turnover || stats.turnover_ratio, // Check both possible names
      turnover_ratio: stats.turnover_ratio, // Check if BallDontLie provides this
      net_rating: stats.net_rating, // Check if BallDontLie provides this
    };
    
    console.log('√∞≈∏¬ß¬Æ Calculated advanced stats:', calculatedStats);
    return calculatedStats;
  } catch (error) {
    console.error('Error fetching advanced stats:', error);
    return null;
  }
}

// Fetch clutch stats from BallDontLie GOAT plan
async function fetchPlayerClutchStats(
  playerId: number,
  season: number
): Promise<{ clutch_usage?: number; clutch_ts?: number; clutch_ppg?: number } | null> {
  try {
    console.log(`Fetching clutch stats for player ${playerId}, season ${season}`);
    
    // Fetch clutch stats using correct endpoint format
    console.log('√∞≈∏≈Ω¬Ø Fetching REAL NBA clutch stats...');
    
    // Method 1: Try /stats/advanced with clutch category
    let clutchUrl = `/api/balldontlie?endpoint=/stats/advanced&player_ids[]=${playerId}&seasons[]=${season}&category=clutch`;
    console.log('√∞≈∏‚Äú≈† Method 1 Clutch URL:', clutchUrl);
    
    let res = await fetch(clutchUrl);
    let data = await res.json();
    
    console.log('√∞≈∏‚Äù¬ç Method 1 Clutch Response:', JSON.stringify(data, null, 2));
    
    // Method 2: If that fails, try season_averages with clutch category
    if (data.error || !data.data || data.data.length === 0) {
      console.log('√∞≈∏‚Äù‚Äû Method 1 failed, trying Method 2...');
      clutchUrl = `/api/balldontlie?endpoint=/season_averages&player_id=${playerId}&season=${season}&category=clutch`;
      console.log('√∞≈∏‚Äú≈† Method 2 Clutch URL:', clutchUrl);
      
      res = await fetch(clutchUrl);
      data = await res.json();
      console.log('√∞≈∏‚Äù¬ç Method 2 Clutch Response:', JSON.stringify(data, null, 2));
    }
    
    console.log('Clutch stats response:', data);
    
    if (data.error) {
      console.error('Clutch stats API Error:', data.error);
      return null;
    }
    
    const statsArray = Array.isArray(data?.data) ? data.data : [];
    if (statsArray.length === 0) {
      console.log('No clutch stats data available');
      return null;
    }
    
    const stats = statsArray[0];
    console.log('Parsed clutch stats:', stats);
    
    return {
      clutch_usage: stats.usage_percentage,
      clutch_ts: stats.true_shooting_percentage,
      clutch_ppg: stats.pts
    };
  } catch (error) {
    console.error('Error fetching clutch stats:', error);
    return null;
  }
}


/* Component */
function ResearchDashboardComponent() {
  const router = useRouter();
  const [themeDark, setThemeDark] = useState(false);
  const [mounted, setMounted] = useState(false);
  
  // Refs for cleanup
  const abortControllerRef = useRef<AbortController | null>(null);

  // Simple search state
  const [searchQuery, setSearchQuery] = useState("");
  const [showSuggestions, setShowSuggestions] = useState(false);
  
  // Chart states
  const [selectedStat, setSelectedStat] = useState("points");
  const [selectedTimeFilter, setSelectedTimeFilter] = useState<
    "last5" | "last10" | "last15" | "last20" | "h2h" | "lastSeason"
  >("last10");
  const [selectedLine, setSelectedLine] = useState(25.5);
  const [viewMode, setViewMode] = useState<"opponent" | "player">("opponent");
  const [boxScorePage, setBoxScorePage] = useState(0);
  const [selectedBookmaker, setSelectedBookmaker] = useState('fanduel');
  const [oddsFormat, setOddsFormat] = useState(() => {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('betting-journal.oddsFormat') || 'american';
    }
    return 'american';
  });

  // Pre-load cached data for instant display (12-hour cache)
  const preloadCachedData = useCallback((playerName: string) => {
    const cacheKey = `player-data-${playerName}`;
    const now = Date.now();
    const twelveHoursMs = 12 * 60 * 60 * 1000;
    
    try {
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const { timestamp } = JSON.parse(cached);
        if (timestamp && (now - timestamp <= twelveHoursMs)) {
          // We have fresh data cached (within 12 hours) - try to load saved stats
          const statsKey = `player-stats-${playerName}`;
          const cachedStats = localStorage.getItem(statsKey);
          if (cachedStats) {
            const { logs, advanced, clutch } = JSON.parse(cachedStats);
            const age = Math.round((now - timestamp) / (1000 * 60)); // Age in minutes
            console.log(`‚òÇÔ∏è Pre-loading cached data for ${playerName} (${age} minutes old)`);
            return { logs: logs || [], advanced, clutch };
          }
        }
      }
    } catch (error) {
      console.log('No valid cached data found for pre-loading');
    }
    return null;
  }, []);

  // Get selected player from URL parameter or default to LeBron James
  const [selectedPlayer, setSelectedPlayer] = useState(() => {
    if (typeof window !== 'undefined') {
      const urlParams = new URLSearchParams(window.location.search);
      const playerParam = urlParams.get('player');
      if (playerParam) {
        const decodedPlayer = decodeURIComponent(playerParam);
        console.log('üèÄ URL player parameter found:', decodedPlayer);
        return decodedPlayer;
      }
    }
    console.log('üèÄ No URL parameter, defaulting to LeBron James');
    return "LeBron James";
  });
  const [selectedTeam, setSelectedTeam] = useState("LAL");
  
  // Initialize games with cached data for instant loading
  const [todaysGames, setTodaysGames] = useState<NBAGame[]>(() => {
    if (typeof window !== 'undefined') {
      try {
        const cached = localStorage.getItem('nba-games-cache');
        if (cached) {
          const { games, timestamp } = JSON.parse(cached);
          const now = Date.now();
          const twelveHoursMs = 12 * 60 * 60 * 1000;
          
          if (timestamp && (now - timestamp <= twelveHoursMs)) {
            const age = Math.round((now - timestamp) / (1000 * 60));
            console.log(`‚ö° Instant loading ${games.length} games (${age} minutes old)`);
            return games;
          }
        }
      } catch {
        console.log('No valid cached games found');
      }
    }
    return [];
  });
  
  const [gamesLoading, setGamesLoading] = useState(() => {
    // Only show loading if we don't have cached games
    if (typeof window !== 'undefined') {
      try {
        const cached = localStorage.getItem('nba-games-cache');
        if (cached) {
          const { timestamp } = JSON.parse(cached);
          const now = Date.now();
          const twelveHoursMs = 12 * 60 * 60 * 1000;
          return !timestamp || (now - timestamp > twelveHoursMs);
        }
      } catch {}
    }
    return true;
  });

  // Initialize with cached data for instant display
  const [playerLogs, setPlayerLogs] = useState<PlayerGameRow[]>(() => {
    if (typeof window !== 'undefined') {
      const urlParams = new URLSearchParams(window.location.search);
      const playerParam = urlParams.get('player');
      if (playerParam) {
        const decodedPlayer = decodeURIComponent(playerParam);
        const cached = preloadCachedData(decodedPlayer);
        if (cached?.logs) {
          console.log(`‚ö° Instant loading ${cached.logs.length} games for ${decodedPlayer}`);
          return cached.logs;
        }
      }
    }
    return [];
  });
  // Only show loading if we don't have pre-loaded data
  const [loadingLogs, setLoadingLogs] = useState(() => {
    if (typeof window !== 'undefined') {
      const urlParams = new URLSearchParams(window.location.search);
      const playerParam = urlParams.get('player');
      if (playerParam) {
        const decodedPlayer = decodeURIComponent(playerParam);
        const cached = preloadCachedData(decodedPlayer);
        return !cached?.logs; // Only loading if no cached data
      }
    }
    return true; // Loading by default for new players
  });
  
  // Advanced stats state - also pre-load from cache
  const [advancedStats, setAdvancedStats] = useState<AdvancedStats | null>(() => {
    if (typeof window !== 'undefined') {
      const urlParams = new URLSearchParams(window.location.search);
      const playerParam = urlParams.get('player');
      if (playerParam) {
        const decodedPlayer = decodeURIComponent(playerParam);
        const cached = preloadCachedData(decodedPlayer);
        if (cached?.advanced) {
          console.log(`‚ö° Instant loading advanced stats for ${decodedPlayer}`);
          return cached.advanced;
        }
      }
    }
    return null;
  });
  const [clutchStats, setClutchStats] = useState<{ clutch_usage?: number; clutch_ts?: number; clutch_ppg?: number } | null>(() => {
    if (typeof window !== 'undefined') {
      const urlParams = new URLSearchParams(window.location.search);
      const playerParam = urlParams.get('player');
      if (playerParam) {
        const decodedPlayer = decodeURIComponent(playerParam);
        const cached = preloadCachedData(decodedPlayer);
        if (cached?.clutch) {
          console.log(`‚ö° Instant loading clutch stats for ${decodedPlayer}`);
          return cached.clutch;
        }
      }
    }
    return null;
  });
  // Only show loading if we don't have pre-loaded advanced stats
  const [loadingAdvancedStats, setLoadingAdvancedStats] = useState(() => {
    if (typeof window !== 'undefined') {
      const urlParams = new URLSearchParams(window.location.search);
      const playerParam = urlParams.get('player');
      if (playerParam) {
        const decodedPlayer = decodeURIComponent(playerParam);
        const cached = preloadCachedData(decodedPlayer);
        return !cached?.advanced; // Only loading if no cached advanced stats
      }
    }
    return true; // Loading by default for new players
  });
  const [currentSeason, setCurrentSeason] = useState<number>(2024); // Dynamic season detection

  // Team roster state
  const [teamRoster, setTeamRoster] = useState<any[]>([]);
  const [loadingRoster, setLoadingRoster] = useState(false);
  const [lastFetchedTeam, setLastFetchedTeam] = useState<string>('');
  
  // Enhanced loading states
  const [loadingStates, setLoadingStates] = useState({
    playerLookup: false,
    gameStats: false,
    advancedStats: false,
    clutchStats: false,
    roster: false,
    games: false
  });
  
  const updateLoadingState = useCallback((key: keyof typeof loadingStates, value: boolean) => {
    setLoadingStates(prev => ({ ...prev, [key]: value }));
  }, []);

  // NBA Team Ratings Data (2024-25 Season) - Exact match from reference table
  const teamRatings: Record<string, { offensive: number; defensive: number; net?: number }> = {
    'CLE': { offensive: 121.0, defensive: 111.8 },  // Rank 1
    'BOS': { offensive: 119.5, defensive: 110.1 },  // Rank 2
    'OKC': { offensive: 119.2, defensive: 106.6 },  // Rank 3
    'DEN': { offensive: 118.9, defensive: 115.1 },  // Rank 4
    'NYK': { offensive: 117.3, defensive: 113.3 },  // Rank 5
    'MEM': { offensive: 117.2, defensive: 112.6 },  // Rank 6
    'SAC': { offensive: 115.9, defensive: 115.3 },  // Rank 7
    'MIN': { offensive: 115.7, defensive: 110.8 },  // Rank 8
    'IND': { offensive: 115.4, defensive: 113.3 },  // Rank 9
    'MIL': { offensive: 115.1, defensive: 112.7 },  // Rank 10
    'LAL': { offensive: 115.0, defensive: 113.8 },  // Rank 11
    'HOU': { offensive: 114.9, defensive: 110.3 },  // Rank 12
    'PHX': { offensive: 114.7, defensive: 117.7 },  // Rank 13
    'DET': { offensive: 114.6, defensive: 112.5 },  // Rank 14
    'LAC': { offensive: 114.3, defensive: 109.4 },  // Rank 15
    'GSW': { offensive: 114.2, defensive: 111.0 },  // Rank 16
    'ATL': { offensive: 113.7, defensive: 114.8 },  // Rank 17
    'DAL': { offensive: 113.7, defensive: 115.0 },  // Rank 18
    'SAS': { offensive: 113.5, defensive: 116.3 },  // Rank 19
    'CHI': { offensive: 113.2, defensive: 114.8 },  // Rank 20
    'MIA': { offensive: 112.4, defensive: 112.0 },  // Rank 21
    'POR': { offensive: 111.0, defensive: 113.7 },  // Rank 22
    'PHI': { offensive: 111.0, defensive: 117.3 },  // Rank 23
    'UTA': { offensive: 110.2, defensive: 119.4 },  // Rank 24
    'NOP': { offensive: 109.7, defensive: 119.1 },  // Rank 25
    'TOR': { offensive: 109.6, defensive: 113.6 },  // Rank 26
    'ORL': { offensive: 108.9, defensive: 109.1 },  // Rank 27
    'BKN': { offensive: 108.1, defensive: 115.4 },  // Rank 28
    'CHA': { offensive: 106.7, defensive: 115.7 },  // Rank 29
    'WAS': { offensive: 105.8, defensive: 118.0 }   // Rank 30
  };

  // Calculate net rating for each team
  Object.keys(teamRatings).forEach(team => {
    teamRatings[team].net = teamRatings[team].offensive - teamRatings[team].defensive;
  });

  // NBA Team Pace Data (2024-25 Season) - Fastest to Slowest
  const teamPace: Record<string, number> = {
    'MEM': 103.69, 'CHI': 103.61, 'ATL': 103.41, 'WAS': 101.82, 'OKC': 100.90,
    'UTA': 100.85, 'IND': 100.76, 'DEN': 100.67, 'TOR': 100.62, 'CLE': 100.31,
    'DET': 100.27, 'DAL': 100.15, 'SAS': 100.08, 'MIL': 99.92, 'NOP': 99.77,
    'POR': 99.51, 'GSW': 99.37, 'HOU': 99.03, 'SAC': 98.91, 'LAL': 98.34,
    'PHX': 98.31, 'LAC': 98.24, 'CHA': 98.22, 'PHI': 98.13, 'MIN': 97.95,
    'NYK': 97.64, 'MIA': 97.08, 'BKN': 96.73, 'BOS': 96.59, 'ORL': 96.51
  };

  // NBA Team Rebound Percentage Data (2024-25 Season)
  const teamReboundPct: Record<string, number> = {
    'MEM': 58.8, 'CHI': 58.5, 'ATL': 57.9, 'WAS': 54.6, 'OKC': 59.3,
    'UTA': 56.8, 'IND': 59.4, 'DEN': 60.4, 'TOR': 55.3, 'CLE': 60.7,
    'DET': 58.0, 'DAL': 58.3, 'SAS': 57.5, 'MIL': 59.8, 'NOP': 55.2,
    'POR': 55.5, 'GSW': 56.8, 'HOU': 55.3, 'SAC': 58.2, 'LAL': 59.3,
    'PHX': 59.5, 'LAC': 58.9, 'CHA': 53.7, 'PHI': 56.3, 'MIN': 58.8,
    'NYK': 58.9, 'MIA': 57.6, 'BKN': 55.2, 'BOS': 59.1, 'ORL': 55.0
  };

  // Opponent defensive stats data (2024-25 season)
  const opponentDefensiveStats: Record<string, {
    ptsAllowed: number;
    rebAllowed: number;
    astAllowed: number;
    fgmAllowed: number;
    fgaAllowed: number;
    fg3mAllowed: number;
    fg3aAllowed: number;
    stlAllowed: number;
    blkAllowed: number;
  }> = {
    'OKC': { ptsAllowed: 107.6, rebAllowed: 44.9, astAllowed: 24.6, fgmAllowed: 37.9, fgaAllowed: 87.0, fg3mAllowed: 13.5, fg3aAllowed: 39.3, stlAllowed: 6.7, blkAllowed: 4.8 },
    'CLE': { ptsAllowed: 112.4, rebAllowed: 43.5, astAllowed: 25.6, fgmAllowed: 41.2, fgaAllowed: 90.9, fg3mAllowed: 13.5, fg3aAllowed: 37.5, stlAllowed: 7.8, blkAllowed: 4.4 },
    'BOS': { ptsAllowed: 107.2, rebAllowed: 43.7, astAllowed: 24.0, fgmAllowed: 40.3, fgaAllowed: 89.4, fg3mAllowed: 12.9, fg3aAllowed: 37.1, stlAllowed: 6.9, blkAllowed: 3.6 },
    'HOU': { ptsAllowed: 109.8, rebAllowed: 42.1, astAllowed: 23.5, fgmAllowed: 40.5, fgaAllowed: 88.3, fg3mAllowed: 12.3, fg3aAllowed: 34.5, stlAllowed: 7.9, blkAllowed: 5.7 },
    'NYK': { ptsAllowed: 111.7, rebAllowed: 41.8, astAllowed: 25.2, fgmAllowed: 41.6, fgaAllowed: 87.7, fg3mAllowed: 13.1, fg3aAllowed: 35.7, stlAllowed: 7.0, blkAllowed: 5.0 },
    'DEN': { ptsAllowed: 116.9, rebAllowed: 42.5, astAllowed: 29.0, fgmAllowed: 43.3, fgaAllowed: 93.0, fg3mAllowed: 14.1, fg3aAllowed: 38.7, stlAllowed: 8.7, blkAllowed: 5.1 },
    'IND': { ptsAllowed: 115.1, rebAllowed: 45.0, astAllowed: 26.0, fgmAllowed: 42.6, fgaAllowed: 89.9, fg3mAllowed: 12.9, fg3aAllowed: 36.3, stlAllowed: 7.2, blkAllowed: 4.5 },
    'LAC': { ptsAllowed: 108.2, rebAllowed: 41.5, astAllowed: 25.7, fgmAllowed: 39.5, fgaAllowed: 85.8, fg3mAllowed: 13.0, fg3aAllowed: 37.0, stlAllowed: 8.8, blkAllowed: 4.3 },
    'LAL': { ptsAllowed: 112.2, rebAllowed: 43.0, astAllowed: 27.3, fgmAllowed: 41.4, fgaAllowed: 89.3, fg3mAllowed: 13.6, fg3aAllowed: 38.1, stlAllowed: 8.2, blkAllowed: 4.2 },
    'MIN': { ptsAllowed: 109.3, rebAllowed: 42.9, astAllowed: 24.8, fgmAllowed: 40.5, fgaAllowed: 88.0, fg3mAllowed: 12.7, fg3aAllowed: 36.0, stlAllowed: 8.4, blkAllowed: 4.5 },
    'GSW': { ptsAllowed: 110.5, rebAllowed: 44.1, astAllowed: 25.9, fgmAllowed: 40.4, fgaAllowed: 86.9, fg3mAllowed: 13.2, fg3aAllowed: 36.3, stlAllowed: 7.6, blkAllowed: 5.4 },
    'MEM': { ptsAllowed: 116.9, rebAllowed: 43.5, astAllowed: 27.0, fgmAllowed: 41.9, fgaAllowed: 91.8, fg3mAllowed: 14.2, fg3aAllowed: 39.4, stlAllowed: 8.7, blkAllowed: 5.5 },
    'MIL': { ptsAllowed: 113.0, rebAllowed: 45.3, astAllowed: 26.4, fgmAllowed: 41.6, fgaAllowed: 91.1, fg3mAllowed: 13.9, fg3aAllowed: 39.4, stlAllowed: 7.3, blkAllowed: 3.8 },
    'DET': { ptsAllowed: 113.6, rebAllowed: 42.5, astAllowed: 24.8, fgmAllowed: 40.6, fgaAllowed: 87.9, fg3mAllowed: 13.6, fg3aAllowed: 37.2, stlAllowed: 8.9, blkAllowed: 5.0 },
    'ORL': { ptsAllowed: 105.5, rebAllowed: 42.1, astAllowed: 22.8, fgmAllowed: 38.1, fgaAllowed: 81.5, fg3mAllowed: 11.4, fg3aAllowed: 31.4, stlAllowed: 7.7, blkAllowed: 4.4 },
    'ATL': { ptsAllowed: 119.3, rebAllowed: 43.7, astAllowed: 28.2, fgmAllowed: 43.4, fgaAllowed: 90.2, fg3mAllowed: 14.3, fg3aAllowed: 37.8, stlAllowed: 9.2, blkAllowed: 4.9 },
    'SAC': { ptsAllowed: 115.3, rebAllowed: 42.3, astAllowed: 27.0, fgmAllowed: 41.6, fgaAllowed: 87.8, fg3mAllowed: 14.5, fg3aAllowed: 38.2, stlAllowed: 7.9, blkAllowed: 4.3 },
    'CHI': { ptsAllowed: 119.4, rebAllowed: 46.1, astAllowed: 28.9, fgmAllowed: 44.4, fgaAllowed: 95.0, fg3mAllowed: 13.6, fg3aAllowed: 39.6, stlAllowed: 8.1, blkAllowed: 5.1 },
    'DAL': { ptsAllowed: 115.4, rebAllowed: 45.3, astAllowed: 27.1, fgmAllowed: 43.1, fgaAllowed: 91.7, fg3mAllowed: 12.9, fg3aAllowed: 35.4, stlAllowed: 8.1, blkAllowed: 4.6 },
    'MIA': { ptsAllowed: 110.0, rebAllowed: 44.7, astAllowed: 26.5, fgmAllowed: 41.3, fgaAllowed: 88.6, fg3mAllowed: 13.6, fg3aAllowed: 37.9, stlAllowed: 7.5, blkAllowed: 4.7 },
    'PHX': { ptsAllowed: 116.6, rebAllowed: 44.2, astAllowed: 27.3, fgmAllowed: 42.6, fgaAllowed: 90.1, fg3mAllowed: 14.2, fg3aAllowed: 38.4, stlAllowed: 8.5, blkAllowed: 4.0 },
    'POR': { ptsAllowed: 113.9, rebAllowed: 44.2, astAllowed: 26.2, fgmAllowed: 41.6, fgaAllowed: 88.3, fg3mAllowed: 12.7, fg3aAllowed: 35.2, stlAllowed: 9.5, blkAllowed: 5.5 },
    'SAS': { ptsAllowed: 116.7, rebAllowed: 46.2, astAllowed: 28.0, fgmAllowed: 43.8, fgaAllowed: 92.5, fg3mAllowed: 14.4, fg3aAllowed: 39.3, stlAllowed: 8.1, blkAllowed: 4.3 },
    'TOR': { ptsAllowed: 115.2, rebAllowed: 45.0, astAllowed: 25.9, fgmAllowed: 41.2, fgaAllowed: 88.3, fg3mAllowed: 13.2, fg3aAllowed: 37.7, stlAllowed: 9.2, blkAllowed: 5.9 },
    'BKN': { ptsAllowed: 112.2, rebAllowed: 43.7, astAllowed: 27.1, fgmAllowed: 40.5, fgaAllowed: 84.3, fg3mAllowed: 12.9, fg3aAllowed: 35.7, stlAllowed: 8.0, blkAllowed: 5.6 },
    'PHI': { ptsAllowed: 115.8, rebAllowed: 45.5, astAllowed: 28.3, fgmAllowed: 42.4, fgaAllowed: 86.8, fg3mAllowed: 14.2, fg3aAllowed: 37.6, stlAllowed: 7.4, blkAllowed: 5.1 },
    'NOP': { ptsAllowed: 119.3, rebAllowed: 45.7, astAllowed: 28.6, fgmAllowed: 43.7, fgaAllowed: 90.5, fg3mAllowed: 14.6, fg3aAllowed: 41.1, stlAllowed: 9.0, blkAllowed: 5.2 },
    'CHA': { ptsAllowed: 114.2, rebAllowed: 45.2, astAllowed: 26.8, fgmAllowed: 41.6, fgaAllowed: 88.9, fg3mAllowed: 14.2, fg3aAllowed: 40.0, stlAllowed: 8.8, blkAllowed: 5.3 },
    'WAS': { ptsAllowed: 120.4, rebAllowed: 48.9, astAllowed: 28.5, fgmAllowed: 43.7, fgaAllowed: 92.8, fg3mAllowed: 14.3, fg3aAllowed: 39.2, stlAllowed: 9.1, blkAllowed: 5.2 },
    'UTA': { ptsAllowed: 121.2, rebAllowed: 44.2, astAllowed: 29.6, fgmAllowed: 44.6, fgaAllowed: 93.0, fg3mAllowed: 14.9, fg3aAllowed: 41.5, stlAllowed: 9.8, blkAllowed: 6.4 }
  };

  // Get opponent defensive rank for a specific stat
  const getOpponentDefensiveRank = (teamAbbr: string, statType: 'ptsAllowed' | 'rebAllowed' | 'astAllowed' | 'fgmAllowed' | 'fgaAllowed' | 'fg3mAllowed' | 'fg3aAllowed' | 'stlAllowed' | 'blkAllowed'): number => {
    // Create array of teams with their defensive stats for sorting
    const teamsWithStats = Object.entries(opponentDefensiveStats).map(([team, stats]) => ({
      team,
      value: stats[statType] || 999
    }));

    // Sort by value - LOWER is BETTER for defense (rank 1 = best defense)
    teamsWithStats.sort((a, b) => a.value - b.value);

    // Find the rank (1-based index)
    const rank = teamsWithStats.findIndex(t => t.team === teamAbbr) + 1;
    return rank > 0 ? rank : 30; // Default to 30th if team not found
  };

  // Get opponent defensive rank color (inverted logic - bad defense is good for your player)
  const getOpponentDefensiveRankColor = (rank: number): string => {
    // For opponent defense: higher rank = worse defense = better for your player
    if (rank >= 25) return 'text-green-500';       // Excellent (25th-30th worst defense)
    if (rank >= 19) return 'text-green-400';       // Very good (19th-24th)
    if (rank >= 13) return 'text-orange-500';      // Okay (13th-18th)
    if (rank >= 7) return 'text-red-400';          // Pretty bad (7th-12th)
    return 'text-red-500';                         // Bad (1st-6th best defense)
  };

  // Get team ratings with fallback
  const getTeamRating = (teamAbbr: string, type: 'offensive' | 'defensive' | 'net') => {
    return teamRatings[teamAbbr]?.[type] ?? 0.0;
  };

  // Get team rank for a specific rating type
  const getTeamRank = (teamAbbr: string, type: 'offensive' | 'defensive' | 'net') => {
    // Create array of teams with their ratings for sorting
    const teamsWithRatings = Object.entries(teamRatings).map(([team, ratings]) => ({
      team,
      rating: ratings[type] || 0
    }));

    // Sort based on rating type (higher is better for offensive/net, lower is better for defensive)
    teamsWithRatings.sort((a, b) => {
      if (type === 'defensive') {
        return a.rating - b.rating; // Lower defensive rating is better (rank 1)
      }
      return b.rating - a.rating; // Higher offensive/net rating is better (rank 1)
    });

    // Find the rank (1-based index)
    const rank = teamsWithRatings.findIndex(t => t.team === teamAbbr) + 1;
    return rank > 0 ? rank : 30; // Default to 30th if team not found
  };

  // Add ordinal suffix to numbers (1st, 2nd, 3rd, 4th, etc.)
  const getOrdinalSuffix = (num: number): string => {
    const lastDigit = num % 10;
    const lastTwoDigits = num % 100;
    
    // Special cases for 11th, 12th, 13th
    if (lastTwoDigits >= 11 && lastTwoDigits <= 13) {
      return num + 'th';
    }
    
    // Standard cases
    switch (lastDigit) {
      case 1: return num + 'st';
      case 2: return num + 'nd';
      case 3: return num + 'rd';
      default: return num + 'th';
    }
  };

  // Get pace value for a team
  const getTeamPace = (teamAbbr: string): number => {
    return teamPace[teamAbbr] ?? 0.0;
  };

  // Get rebound percentage for a team
  const getTeamReboundPct = (teamAbbr: string): number => {
    return teamReboundPct[teamAbbr] ?? 0.0;
  };

  // Get pace rank for a team (higher pace = better for overs)
  const getPaceRank = (teamAbbr: string): number => {
    const paceArray = Object.entries(teamPace).map(([team, pace]) => ({ team, pace }));
    paceArray.sort((a, b) => b.pace - a.pace); // Higher pace = better rank
    const rank = paceArray.findIndex(t => t.team === teamAbbr) + 1;
    return rank > 0 ? rank : 30;
  };

  // Get rebound percentage rank for a team (higher rebound % = better for overs)
  const getReboundRank = (teamAbbr: string): number => {
    const reboundArray = Object.entries(teamReboundPct).map(([team, rebPct]) => ({ team, rebPct }));
    reboundArray.sort((a, b) => b.rebPct - a.rebPct); // Higher rebound % = better rank
    const rank = reboundArray.findIndex(t => t.team === teamAbbr) + 1;
    return rank > 0 ? rank : 30;
  };

  // Get color based on team rank for overs betting (5-tier system)
  const getRankColor = (rank: number, type: 'offensive' | 'defensive' | 'net' | 'pace' | 'rebound' | 'opponent_rebound' | 'opponent_net'): string => {
    if (type === 'offensive' || type === 'net' || type === 'pace' || type === 'rebound') {
      // For offensive/net/pace/rebound: lower rank = better for overs
      if (rank <= 6) return 'text-green-500';        // Excellent (1st-6th)
      if (rank <= 12) return 'text-green-400';       // Very good (7th-12th) 
      if (rank <= 18) return 'text-orange-500';      // Okay (13th-18th)
      if (rank <= 24) return 'text-red-400';         // Pretty bad (19th-24th)
      return 'text-red-500';                         // Bad (25th-30th)
    } else if (type === 'opponent_rebound' || type === 'opponent_net') {
      // For opponent rebound/net: higher rank = worse performance = better for your player
      if (rank >= 25) return 'text-green-500';       // Excellent (25th-30th worst performance)
      if (rank >= 19) return 'text-green-400';       // Very good (19th-24th)
      if (rank >= 13) return 'text-orange-500';      // Okay (13th-18th)
      if (rank >= 7) return 'text-red-400';          // Pretty bad (7th-12th)
      return 'text-red-500';                         // Bad (1st-6th best performance)
    } else {
      // For defensive: higher rank = worse defense = better for overs
      if (rank >= 25) return 'text-green-500';       // Excellent (25th-30th worst defense)
      if (rank >= 19) return 'text-green-400';       // Very good (19th-24th)
      if (rank >= 13) return 'text-orange-500';      // Okay (13th-18th)
      if (rank >= 7) return 'text-red-400';          // Pretty bad (7th-12th)
      return 'text-red-500';                         // Bad (1st-6th best defense)
    }
  };

  // --- Dynamic Season Detection & Daily Cache ---
  const getCurrentActiveSeason = async (): Promise<number> => {
    const cacheKey = 'season-detection-cache';
    const today = new Date().toDateString();
    
    // Check if we have today's season detection cached
    const cached = localStorage.getItem(cacheKey);
    if (cached) {
      const { season, date } = JSON.parse(cached);
      if (date === today) {
        console.log(`√∞≈∏‚Äî‚Äú√Ø¬∏¬è Using cached season detection: ${season} (${date})`);
        return season;
      }
    }
    
    console.log('√∞≈∏‚Äù¬ç Detecting current active NBA season...');
    
    try {
      // Test if 2025 season has data by checking a well-known active player
      const testPlayerId = 237; // LeBron James ID for testing
      const season2025Url = `/api/balldontlie?endpoint=/season_averages&player_id=${testPlayerId}&season=2025`;
      
      const response = await fetch(season2025Url);
      const data = await response.json();
      
      // If 2025 season has data, use it; otherwise stick with 2024
      let activeSeason = 2024;
      if (data?.data && data.data.length > 0) {
        // Check if the data has meaningful stats (games played > 0)
        const stats = data.data[0];
        if (stats.games_played && stats.games_played > 0) {
          activeSeason = 2025;
          console.log('√∞≈∏¬è‚Ç¨ 2025 NBA season is active with live data!');
        }
      }
      
      if (activeSeason === 2024) {
        console.log('√∞≈∏‚Äú‚Ä¶ 2025 season not yet active, using 2024 completed season');
      }
      
      // Cache the result for today
      localStorage.setItem(cacheKey, JSON.stringify({ season: activeSeason, date: today }));
      
      return activeSeason;
    } catch (error) {
      console.error('Error detecting season:', error);
      // Fallback to 2024 if detection fails
      return 2024;
    }
  };
  
  // 12-hour cache invalidation for player stats
  const shouldRefreshPlayerData = (playerName: string): boolean => {
    const cacheKey = `player-data-${playerName}`;
    const now = Date.now();
    const twelveHoursMs = 12 * 60 * 60 * 1000;
    
    const cached = localStorage.getItem(cacheKey);
    if (!cached) return true;
    
    try {
      const { timestamp } = JSON.parse(cached);
      const needsRefresh = !timestamp || (now - timestamp > twelveHoursMs);
      
      if (needsRefresh) {
        const lastUpdate = timestamp ? new Date(timestamp).toLocaleString() : 'unknown';
        console.log(`üîÑ 12-hour refresh needed for ${playerName} (last updated: ${lastUpdate})`);
      }
      
      return needsRefresh;
    } catch {
      return true; // If cache is corrupted, refresh
    }
  };
  
  const markPlayerDataCached = (playerName: string) => {
    const cacheKey = `player-data-${playerName}`;
    const timestamp = Date.now();
    localStorage.setItem(cacheKey, JSON.stringify({ timestamp }));
  };

  // --- Dynamic Betting Line Calculation ---
  const calculateDynamicLine = (chartData: any[], selectedStat: string, selectedPlayer: string) => {
    if (!chartData.length) {
      console.log('√∞≈∏‚Äú≈† No chart data for line calculation');
      return 25.5; // Default fallback
    }

    const values = chartData.map(d => d.value).filter(v => v !== undefined && v !== null);
    if (!values.length) {
      console.log('√∞≈∏‚Äú≈† No valid values for line calculation');
      return 25.5;
    }

    // Calculate season average
    const seasonAvg = values.reduce((a, b) => a + b, 0) / values.length;
    
    // Calculate recent form (last 5 games average)
    const recentGames = values.slice(-Math.min(5, values.length));
    const recentAvg = recentGames.reduce((a, b) => a + b, 0) / recentGames.length;
    
    // Calculate standard deviation for consistency
    const variance = values.reduce((acc, val) => acc + Math.pow(val - seasonAvg, 2), 0) / values.length;
    const stdDev = Math.sqrt(variance);
    
    // Weight recent form more heavily if player is hot/cold
    const formWeight = Math.abs(recentAvg - seasonAvg) > (stdDev * 0.5) ? 0.4 : 0.2;
    const adjustedAvg = (seasonAvg * (1 - formWeight)) + (recentAvg * formWeight);
    
    // Apply slight adjustment based on stat type
    let statMultiplier = 1.0;
    if (selectedStat === 'points' || selectedStat === 'pts') {
      statMultiplier = 0.98; // Slightly conservative for points
    } else if (selectedStat === 'rebounds' || selectedStat === 'reb') {
      statMultiplier = 1.02; // Slightly generous for rebounds
    } else if (selectedStat === 'assists' || selectedStat === 'ast') {
      statMultiplier = 0.95; // More conservative for assists
    } else if (selectedStat === '3pm' || selectedStat === 'fg3m') {
      statMultiplier = 0.92; // Conservative for 3-pointers
    }
    
    const calculatedLine = adjustedAvg * statMultiplier;
    
    // Round to nearest 0.5 (typical betting line increment)
    const roundedLine = Math.round(calculatedLine * 2) / 2;
    
    console.log(`√∞≈∏‚Äú≈† Dynamic line calculation for ${selectedPlayer} ${selectedStat}:`, {
      seasonAvg: seasonAvg.toFixed(2),
      recentAvg: recentAvg.toFixed(2),
      stdDev: stdDev.toFixed(2),
      formWeight: formWeight,
      adjustedAvg: adjustedAvg.toFixed(2),
      statMultiplier,
      calculatedLine: calculatedLine.toFixed(2),
      finalLine: roundedLine
    });
    
    return roundedLine;
  };

  // Test Odds API for real betting lines with 30-minute caching
  const fetchRealBettingLines = async (playerName: string, stat: string) => {
    const cacheKey = 'odds-api-cache';
    const cacheExpiryMinutes = 30;
    
    // Check for cached odds data
    const cached = localStorage.getItem(cacheKey);
    if (cached) {
      const { data, timestamp } = JSON.parse(cached);
      const now = Date.now();
      const cacheAge = (now - timestamp) / (1000 * 60); // Age in minutes
      
      if (cacheAge < cacheExpiryMinutes) {
        console.log(`√∞≈∏‚Äô¬æ Using cached odds data (${Math.round(cacheAge)} minutes old, expires in ${Math.round(cacheExpiryMinutes - cacheAge)} minutes)`);
        return data.playerProps || null;
      } else {
        console.log(`√∞≈∏‚Äù‚Äû Odds cache expired (${Math.round(cacheAge)} minutes old), fetching fresh data...`);
      }
    }
    
    try {
      console.log(`√∞≈∏≈Ω¬Ø Fetching fresh Odds API data for ${playerName} ${stat} props...`);
      
      const apiKey = '05980d62f6bac38623b1c62cc41a2121';
      
      // First, get NBA events/games
      const eventsUrl = `https://api.the-odds-api.com/v4/sports/basketball_nba/events?apiKey=${apiKey}`;
      console.log('√∞≈∏¬è‚Ç¨ Fetching NBA events:', eventsUrl);
      
      const eventsResponse = await fetch(eventsUrl);
      console.log('√∞≈∏‚Äú¬° Events response status:', eventsResponse.status);
      
      // Check API usage from headers
      const requestsUsed = eventsResponse.headers.get('x-requests-used');
      const requestsRemaining = eventsResponse.headers.get('x-requests-remaining');
      const timestamp = new Date().toLocaleTimeString();
      if (requestsUsed || requestsRemaining) {
        console.log(`√∞≈∏‚Äú≈† API Usage @ ${timestamp} - Used: ${requestsUsed}, Remaining: ${requestsRemaining}`);
      }
      
      if (!eventsResponse.ok) {
        const errorText = await eventsResponse.text();
        console.log('√¢¬ù≈í Events API error:', errorText);
        return null;
      }
      
      const events = await eventsResponse.json();
      console.log('√∞≈∏¬è‚Ä† NBA events data:', JSON.stringify(events, null, 2));
      
      if (!events || events.length === 0) {
        console.log('√∞≈∏‚Äú‚Ä¶ No NBA events available yet (season hasn\'t started)');
        return null;
      }
      
      // Try to get player props for the first event
      const firstEvent = events[0];
      console.log('√∞≈∏≈Ω¬Ø Testing player props for event:', firstEvent.id);
      
      const playerPropsUrl = `https://api.the-odds-api.com/v4/sports/basketball_nba/events/${firstEvent.id}/odds?apiKey=${apiKey}&regions=us&markets=player_points,player_rebounds,player_assists,player_threes&oddsFormat=american&bookmakers=draftkings,fanduel,betmgm`;
      console.log('√∞≈∏¬è‚Ç¨ Fetching player props (with regions & bookmakers):', playerPropsUrl);
      
      const propsResponse = await fetch(playerPropsUrl);
      console.log('√∞≈∏‚Äú≈† Player props response status:', propsResponse.status);
      
      if (!propsResponse.ok) {
        const errorText = await propsResponse.text();
        console.log('√¢¬ù≈í Player props error:', propsResponse.status, errorText);
        
        // Log the full error details for debugging
        console.log('√∞≈∏‚Äù¬ç Full error response:');
        console.log('  - Status:', propsResponse.status);
        console.log('  - StatusText:', propsResponse.statusText);
        console.log('  - Headers:', Object.fromEntries(propsResponse.headers.entries()));
        console.log('  - Error body:', errorText);
        
        return null;
      }
      
      const propsData = await propsResponse.json();
      console.log('√∞≈∏≈Ω¬Ø Player props data:', JSON.stringify(propsData, null, 2));
      
      // Cache the successful API response for 30 minutes
      const cacheData = {
        data: {
          events: events,
          playerProps: propsData
        },
        timestamp: Date.now()
      };
      localStorage.setItem(cacheKey, JSON.stringify(cacheData));
      console.log('√¢≈ì‚Ä¶ Successfully fetched and cached player props data for 30 minutes!');
      
      // Look for the specific player and stat
      // This would need more logic to match player names and stats
      return null; // Still return null for now, just testing
      
    } catch (error) {
      console.error('√∞≈∏‚Äô¬• Odds API error:', error);
      return null;
    }
  };

  // --- Games fetch with dynamic dates and caching ---
  const fetchTodaysGames = async () => {
    try {
      // Check if we have fresh cached games first
      const cached = localStorage.getItem('nba-games-cache');
      if (cached) {
        const { games, timestamp } = JSON.parse(cached);
        const now = Date.now();
        const twelveHoursMs = 12 * 60 * 60 * 1000;
        
        if (timestamp && (now - timestamp <= twelveHoursMs)) {
          const age = Math.round((now - timestamp) / (1000 * 60));
          console.log(`‚ú® Using cached games (${age} minutes old, ${games.length} games)`);
          setTodaysGames(games);
          setGamesLoading(false);
          return;
        }
      }
      
      setGamesLoading(true);
      
      // Generate dynamic date ranges
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(today.getDate() - 1);
      const tomorrow = new Date(today);
      tomorrow.setDate(today.getDate() + 1);
      
      const formatDate = (date: Date) => {
        return date.toISOString().split('T')[0];
      };
      
      const dateRanges = [
        { start: formatDate(yesterday), end: formatDate(tomorrow) }, // Today +/- 1 day
        { start: formatDate(new Date(today.getFullYear(), 9, 15)), end: formatDate(new Date(today.getFullYear(), 9, 25)) }, // Mid October current year
        { start: formatDate(new Date(today.getFullYear() - 1, 9, 15)), end: formatDate(new Date(today.getFullYear() - 1, 9, 25)) }, // Mid October last year
      ];
      
      for (const range of dateRanges) {
        try {
          const url = `/api/balldontlie?endpoint=/games&start_date=${range.start}&end_date=${range.end}&per_page=20`;
          console.log(`Trying games fetch: ${url}`);
          const data = await fetchWithRetry(url);
          
          if (data?.data?.length > 0) {
            console.log(`Found ${data.data.length} games for ${range.start} to ${range.end}`);
            const games = Array.isArray(data.data) ? data.data : [];
            setTodaysGames(games);
            
            // Cache the games data for instant loading
            const gamesCache = {
              games,
              timestamp: Date.now(),
              dateRange: range
            };
            localStorage.setItem('nba-games-cache', JSON.stringify(gamesCache));
            console.log(`‚ö° Games cached for instant loading on refresh`);
            
            return;
          }
        } catch (error) {
          console.error(`Failed to fetch games for ${range.start}-${range.end}:`, error);
        }
      }
      
      console.log('No games found for any date range');
      setTodaysGames([]);
    } catch (error) {
      console.error('Error in fetchTodaysGames:', error);
      setTodaysGames([]);
    } finally {
      setGamesLoading(false);
    }
  };

  // --- helpers ---
  const getPlayerTeam = (playerName: string) => {
    for (const [teamAbbr, players] of Object.entries(ESPN_NBA_ROSTERS_CURRENT)) {
      if ((players as string[]).includes(playerName)) return teamAbbr;
    }
    return "LAL";
  };

  // Simple player search - matches player names from roster
  const getPlayerMatches = (query: string): string[] => {
    if (!query || query.length < 2) return [];
    
    const allPlayers = Object.values(ESPN_NBA_ROSTERS_CURRENT).flat();
    const searchTerm = query.toLowerCase().trim();
    
    return allPlayers
      .filter(player => player.toLowerCase().includes(searchTerm))
      .sort((a, b) => {
        const aLower = a.toLowerCase();
        const bLower = b.toLowerCase();
        
        // Exact match first
        if (aLower === searchTerm) return -1;
        if (bLower === searchTerm) return 1;
        
        // Starts with query
        if (aLower.startsWith(searchTerm) && !bLower.startsWith(searchTerm)) return -1;
        if (!aLower.startsWith(searchTerm) && bLower.startsWith(searchTerm)) return 1;
        
        return a.localeCompare(b);
      })
      .slice(0, 8);
  };

  // Search useEffects removed

  // Handle URL parameter changes
  useEffect(() => {
    const handleUrlChange = () => {
      const urlParams = new URLSearchParams(window.location.search);
      const playerParam = urlParams.get('player');
      if (playerParam) {
        const decodedPlayer = decodeURIComponent(playerParam);
        console.log('√∞≈∏‚Äù‚Äû URL changed, updating player to:', decodedPlayer);
        setSelectedPlayer(decodedPlayer);
      }
    };

    // Listen for popstate events (back/forward navigation)
    window.addEventListener('popstate', handleUrlChange);
    
    return () => {
      window.removeEventListener('popstate', handleUrlChange);
    };
  }, []);

  // Smart cache management - 12 hour cache for fresher stats
  const clearExpiredCaches = useCallback(() => {
    const now = Date.now();
    const twelveHoursMs = 12 * 60 * 60 * 1000; // 12 hours instead of 24
    const keys = Object.keys(localStorage);
    let cleared = 0;
    
    keys.forEach(key => {
      if (key.includes('player-data-') || key.includes('player-stats-') || key.includes('nba-games-cache') || key.includes('season-detection-cache')) {
        try {
          const cached = localStorage.getItem(key);
          if (cached) {
            const { timestamp } = JSON.parse(cached);
            if (timestamp && (now - timestamp > twelveHoursMs)) {
              localStorage.removeItem(key);
              cleared++;
            }
          }
        } catch {
          // Invalid cache entry, remove it
          localStorage.removeItem(key);
          cleared++;
        }
      }
    });
    
    if (cleared > 0) {
      console.log(`üßπ Cleared ${cleared} expired cache entries`);
    }
  }, []);

  useEffect(() => {
    setMounted(true);
    const saved = localStorage.getItem("betting-journal.themeDark");
    setThemeDark(saved === "1");
    
    // Only clear expired caches, not all caches
    clearExpiredCaches();
    
    fetchTodaysGames();
    
    // Load cached roster data on mount if available
    const initialTeam = getPlayerTeam(selectedPlayer);
    const cacheKey = `team-roster-${initialTeam}`;
    const sixHoursMs = 6 * 60 * 60 * 1000;
    
    try {
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const { roster, timestamp } = JSON.parse(cached);
        if (timestamp && (Date.now() - timestamp <= sixHoursMs)) {
          const age = Math.round((Date.now() - timestamp) / (1000 * 60 * 60));
          console.log(`‚ö° Instant loading cached roster for ${initialTeam} (${age}h old)`);
          setTeamRoster(roster);
          setLastFetchedTeam(initialTeam);
          // Still need to load depth chart if not available
          if (!realDepthChart) {
            console.log(`üï∑Ô∏è Loading depth chart for cached roster: ${initialTeam}`);
            fetchRealDepthChart(initialTeam);
          }
          return; // Skip fresh fetch since we have cached data
        }
      }
    } catch {}
    
    // Auto-fetch initial team roster only if not cached
    if (initialTeam && teamRoster.length === 0) {
      console.log(`üèÄ Auto-fetching initial roster for ${initialTeam}`);
      fetchTeamRoster(initialTeam);
    } else if (initialTeam && !realDepthChart) {
      // If we have roster but no depth chart, fetch depth chart
      console.log(`üï∑Ô∏è Fetching missing depth chart for ${initialTeam}`);
      fetchRealDepthChart(initialTeam);
    }
    
    // Expose cache clearing function globally for debugging
    if (typeof window !== 'undefined') {
      (window as any).clearAllCaches = () => {
        console.log('üßπ Manual complete cache clearing triggered...');
        const keys = Object.keys(localStorage);
        let cleared = 0;
        keys.forEach(key => {
          if (key.includes('player-data-') || key.includes('player-stats-') || key.includes('nba-games-cache') || key.includes('odds-api-cache') || key.includes('season-detection-cache')) {
            localStorage.removeItem(key);
            cleared++;
          }
        });
        playerIdCache.clear();
        failedLookupCache.clear();
        console.log(`‚úÖ Manually cleared ${cleared} cache entries`);
        window.location.reload();
      };
    }
  }, [clearExpiredCaches]);
  
  // Handle URL parameters properly for dashboard page only
  useEffect(() => {
    if (mounted) {
      const urlParams = new URLSearchParams(window.location.search);
      const playerParam = urlParams.get('player');
      
      // Only use URL parameter if it's explicitly set and we're on dashboard page
      // Clear the URL parameter to prevent inheritance from other pages
      if (playerParam && window.location.pathname === '/research/dashboard') {
        const decodedPlayer = decodeURIComponent(playerParam);
        console.log('√∞≈∏‚Äù‚Äû Dashboard URL parameter found:', decodedPlayer);
        
        // Only update if different from current selection
        if (decodedPlayer !== selectedPlayer) {
          setSelectedPlayer(decodedPlayer);
        }
      } else if (playerParam) {
        // Clear inherited URL parameters from other research pages
        console.log('√∞≈∏¬ß¬π Clearing inherited URL parameter from other page');
        const newUrl = window.location.pathname; // Remove query params
        window.history.replaceState(null, '', newUrl);
      }
    }
  }, [mounted]);

  useEffect(() => {
    const newTeam = getPlayerTeam(selectedPlayer);
    setSelectedTeam(newTeam);
    // Always reset to L10 filter and points stat when switching players
    setSelectedTimeFilter("last10");
    setSelectedStat("points");
    
    // Auto-fetch team roster when team actually changes (not on refresh)
    if (newTeam !== selectedTeam && mounted) {
      console.log(`üèÄ Auto-fetching roster for team change: ${selectedTeam} ‚Üí ${newTeam}`);
      setTeamRoster([]); // Clear previous roster
      fetchTeamRoster(newTeam);
    }
    
    // Update URL to preserve player selection on refresh
    if (typeof window !== 'undefined' && mounted) {
      const urlParams = new URLSearchParams(window.location.search);
      const currentPlayerParam = urlParams.get('player');
      const encodedPlayer = encodeURIComponent(selectedPlayer);
      
      // Only update URL if player actually changed
      if (currentPlayerParam !== encodedPlayer) {
        router.replace(`${window.location.pathname}?player=${encodedPlayer}`, undefined);
        console.log('üîÑ Updated URL with player:', selectedPlayer);
      }
    }
  }, [selectedPlayer, mounted]);


  // === fetch player logs when player changes ===
  useEffect(() => {
    let cancelled = false;
    
    // Cancel any existing fetch
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    const fetchPlayerData = async () => {
      try {
        console.log('Starting data fetch for player:', selectedPlayer);
        
        // Check if we need to refresh data (daily cache invalidation)
        // BUT always retry if we have no player data (failed lookups)
        const hasExistingData = playerLogs.length > 0 || advancedStats || clutchStats;
        
        // If we pre-loaded data and it's fresh, don't fetch again
        if (!shouldRefreshPlayerData(selectedPlayer) && hasExistingData) {
          console.log(`‚ú® Using cached data for ${selectedPlayer} (updated today)`);
          // Still update loading states to false in case they're true
          setLoadingLogs(false);
          setLoadingAdvancedStats(false);
          return;
        }
        
        if (!hasExistingData) {
          console.log(`üîÑ Retrying failed lookup for ${selectedPlayer} (no existing data)`);
          // Clear failed cache to force retry
          failedLookupCache.delete(selectedPlayer);
          const cacheKey = `player-data-${selectedPlayer}`;
          localStorage.removeItem(cacheKey);
        }
        
        if (signal.aborted || cancelled) return;
        
        setLoadingLogs(true);
        setLoadingAdvancedStats(true);
        setPlayerLogs([]); // Clear previous data
        setAdvancedStats(null);
        setClutchStats(null);
        
        const id = await fetchBDLPlayerIdByName(selectedPlayer);
        if (!id) {
          console.log('No player ID found for:', selectedPlayer);
          if (!cancelled && !signal.aborted) {
            setPlayerLogs([]);
            setAdvancedStats(null);
            setClutchStats(null);
          }
          return;
        }

        if (signal.aborted || cancelled) return;

        // Detect current active season dynamically
        const activeSeason = await getCurrentActiveSeason();
        setCurrentSeason(activeSeason);
        
        console.log(`üìä Fetching live data for ${activeSeason === 2025 ? '2025-26 LIVE' : '2024-25 completed'} season`);
        
        if (signal.aborted || cancelled) return;
        
        // Fetch current season data - will be 2024 until 2025 starts
        const rows = await fetchPlayerGameLogs(id, [activeSeason]);
        
        if (signal.aborted || cancelled) return;
        
        // Fetch advanced stats for current active season
        console.log(`üöÄ Fetching advanced stats for season ${activeSeason}`);
        const [advanced, clutch] = await Promise.all([
          fetchPlayerAdvancedStats(id, activeSeason),
          fetchPlayerClutchStats(id, activeSeason)
        ]);
        
        if (!cancelled && !signal.aborted) {
          console.log('Setting player logs:', rows.length, 'games');
          
          // Debug: check what seasons we actually fetched from API
          const fetchedSeasons = rows.reduce((acc, row) => {
            const season = row.game?.season;
            if (season) {
              acc[season] = (acc[season] || 0) + 1;
            }
            return acc;
          }, {} as Record<number, number>);
          console.log('Seasons fetched from API:', fetchedSeasons);
          
          setPlayerLogs(rows);
          setAdvancedStats(advanced);
          setClutchStats(clutch);
          
          // Mark data as cached for today (daily refresh)
          markPlayerDataCached(selectedPlayer);
          
          // Also cache the actual data for instant loading on refresh
          const statsKey = `player-stats-${selectedPlayer}`;
          const statsData = {
            logs: rows,
            advanced,
            clutch,
            timestamp: Date.now()
          };
          localStorage.setItem(statsKey, JSON.stringify(statsData));
          
          console.log(`‚úÖ Player data cached for ${selectedPlayer} - will refresh tomorrow`);
          console.log(`‚ö° Stats cached for instant loading on refresh`);
        }
      } catch (error) {
        console.error('Error in player data fetch:', error);
        if (!cancelled && !signal.aborted) {
          setPlayerLogs([]);
          setAdvancedStats(null);
          setClutchStats(null);
        }
      } finally {
        if (!cancelled && !signal.aborted) {
          console.log('Finished loading player data');
          setLoadingLogs(false);
          setLoadingAdvancedStats(false);
        }
      }
    };

    fetchPlayerData();

    return () => {
      console.log('Cancelling fetch for:', selectedPlayer);
      cancelled = true;
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [selectedPlayer]);

  // Dedicated useEffect for stat changes - fixes betting line calculation issue
  useEffect(() => {
    if (!playerLogs.length || !selectedStat || !selectedPlayer || selectedPlayer === "Select Player") {
      return;
    }
    
    console.log(`üéØ Recalculating betting line for stat change: ${selectedStat}`);
    
    // Get normalized and sorted data (most recent games first after sorting)
    const currentSeasonData = normalizeAndSort(playerLogs, { season: currentSeason, includePlayoffs: true });
    
    // Get last 20 games (or all available if less than 20)
    const last20Games = currentSeasonData.slice(-20);
    console.log(`üìä Using last ${last20Games.length} games for ${selectedStat} line calculation`);
    
    // Extract stat values using the pickStat helper
    const statValues = last20Games
      .map(log => pickStat(log, selectedStat))
      .filter(val => val > 0); // Filter out games where they didn't play or had 0 in this stat
    
    if (statValues.length > 0) {
      // Calculate average from last 20 games and set as betting line
      const average = statValues.reduce((sum, val) => sum + val, 0) / statValues.length;
      // Always make betting line end in .5 (subtract 0.5 from whole numbers, round half numbers down to .5)
      let bettingLine;
      if (average % 1 === 0) {
        // Whole number: 24.0 becomes 23.5
        bettingLine = average - 0.5;
      } else {
        // Has decimal: round down to nearest .5 (24.7 becomes 24.5, 24.3 becomes 23.5)
        bettingLine = Math.floor(average) + 0.5;
      }
      
      console.log(`üìà Setting ${selectedStat} line to ${bettingLine} (avg from ${statValues.length} games: ${average.toFixed(2)})`);
      setSelectedLine(bettingLine);
    } else {
      console.log(`‚ö†Ô∏è No valid ${selectedStat} data found in recent games`);
      setSelectedLine(0);
    }
  }, [selectedStat, playerLogs, selectedPlayer, currentSeason]); // Listen to stat changes and season

  // ESPN team logo mapping (handles special cases)
  const getESPNLogoName = (teamAbbr: string): string => {
    const logoMapping: Record<string, string> = {
      'NOP': 'no',    // New Orleans Pelicans ‚Üí 'no'
      'UTA': 'utah',  // Utah Jazz ‚Üí 'utah' 
      'PHX': 'phx'    // Phoenix Suns ‚Üí 'phx' (sometimes 'phoenix')
    };
    return logoMapping[teamAbbr.toUpperCase()] || teamAbbr.toLowerCase();
  };

  // Map team ID to abbreviation (BallDontLie team IDs)
  const getTeamAbbreviationById = (teamId: number) => {
    const teamMap: Record<number, string> = {
      1: 'ATL', 2: 'BOS', 3: 'BKN', 4: 'CHA', 5: 'CHI',
      6: 'CLE', 7: 'DAL', 8: 'DEN', 9: 'DET', 10: 'GSW',
      11: 'HOU', 12: 'IND', 13: 'LAC', 14: 'LAL', 15: 'MEM',
      16: 'MIA', 17: 'MIL', 18: 'MIN', 19: 'NOP', 20: 'NYK',
      21: 'OKC', 22: 'ORL', 23: 'PHI', 24: 'PHX', 25: 'POR',
      26: 'SAC', 27: 'SAS', 28: 'TOR', 29: 'UTA', 30: 'WAS'
    };
    return teamMap[teamId] || 'UNK';
  };

  // Get team ID from abbreviation (inverse mapping)
  const getTeamIdByAbbreviation = (abbr: string): number | null => {
    const teamMap: Record<string, number> = {
      'ATL': 1, 'BOS': 2, 'BKN': 3, 'CHA': 4, 'CHI': 5,
      'CLE': 6, 'DAL': 7, 'DEN': 8, 'DET': 9, 'GSW': 10,
      'HOU': 11, 'IND': 12, 'LAC': 13, 'LAL': 14, 'MEM': 15,
      'MIA': 16, 'MIL': 17, 'MIN': 18, 'NOP': 19, 'NYK': 20,
      'OKC': 21, 'ORL': 22, 'PHI': 23, 'PHX': 24, 'POR': 25,
      'SAC': 26, 'SAS': 27, 'TOR': 28, 'UTA': 29, 'WAS': 30
    };
    return teamMap[abbr] || null;
  };

  // Fetch team roster from ESPN API with caching
  const fetchTeamRoster = async (teamAbbr: string) => {
    // Prevent duplicate fetches
    if (loadingRoster || lastFetchedTeam === teamAbbr) {
      console.log(`üõë Skipping duplicate roster fetch for ${teamAbbr}`);
      return;
    }
    
    // Check cache first (6 hour cache)
    const cacheKey = `team-roster-${teamAbbr}`;
    const sixHoursMs = 6 * 60 * 60 * 1000;
    
    try {
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const { roster, timestamp } = JSON.parse(cached);
        if (timestamp && (Date.now() - timestamp <= sixHoursMs)) {
          const age = Math.round((Date.now() - timestamp) / (1000 * 60 * 60));
          console.log(`üíæ Using cached roster for ${teamAbbr} (${age}h old)`);
          setTeamRoster(roster);
          setLastFetchedTeam(teamAbbr);
          // Still fetch depth chart if needed
          if (!realDepthChart || realDepthChart.source !== 'ESPN') {
            fetchRealDepthChart(teamAbbr);
          }
          return;
        }
      }
    } catch {}
    
    setLoadingRoster(true);
    setLastFetchedTeam(teamAbbr);
    
    try {
      console.log(`üèÄ Fetching fresh team roster for ${teamAbbr} from ESPN`);
      
      const response = await fetch(`/api/espn-roster?team=${teamAbbr}`);
      const data = await response.json();
      
      console.log('üìã ESPN Roster API response:', data);
      
      if (!data.success) {
        console.error('ESPN Roster API Error:', data.error);
        setTeamRoster([]);
        return;
      }
      
      const players = data.players || [];
      console.log(`‚úÖ Fetched ${players.length} players for ${teamAbbr}`);
      
      // Sort players by position and jersey number
      const sortedPlayers = players.sort((a: any, b: any) => {
        // Position order: PG, SG, SF, PF, C, G, F
        const positionOrder = { 'PG': 1, 'SG': 2, 'SF': 3, 'PF': 4, 'C': 5, 'G': 1.5, 'F': 3.5 };
        const aPos = positionOrder[a.position as keyof typeof positionOrder] || 6;
        const bPos = positionOrder[b.position as keyof typeof positionOrder] || 6;
        
        if (aPos !== bPos) return aPos - bPos;
        
        // If same position, sort by jersey number
        const aNum = parseInt(a.jersey) || 999;
        const bNum = parseInt(b.jersey) || 999;
        return aNum - bNum;
      });
      
      setTeamRoster(sortedPlayers);
      
      // Cache the roster for 6 hours
      const cacheData = {
        roster: sortedPlayers,
        timestamp: Date.now()
      };
      localStorage.setItem(cacheKey, JSON.stringify(cacheData));
      console.log(`üíæ Cached roster for ${teamAbbr} (6h expiry)`);
      
      // Also fetch real depth chart for this team
      fetchRealDepthChart(teamAbbr);
    } catch (error) {
      console.error('Error fetching team roster:', error);
      setTeamRoster([]);
      setRealDepthChart(null);
    } finally {
      setLoadingRoster(false);
    }
  };

  // Group players by position for depth chart display
  const groupPlayersByPosition = (players: any[]) => {
    const positions = {
      PG: [] as any[],
      SG: [] as any[],
      SF: [] as any[],
      PF: [] as any[],
      C: [] as any[],
      Other: [] as any[]
    };

    players.forEach(player => {
      const pos = player.position as string;
      if (pos === 'PG' || pos === 'SG' || pos === 'SF' || pos === 'PF' || pos === 'C') {
        positions[pos as keyof typeof positions].push(player);
      } else {
        // Handle G, F, or unknown positions
        if (pos === 'G') {
          positions.PG.push(player);
        } else if (pos === 'F') {
          positions.PF.push(player);
        } else {
          positions.Other.push(player);
        }
      }
    });

    return positions;
  };
  
  // Fetch real depth chart data from ESPN scraper
  const [realDepthChart, setRealDepthChart] = useState<any>(null);
  const [loadingDepthChart, setLoadingDepthChart] = useState(false);
  
  const fetchRealDepthChart = async (teamAbbr: string) => {
    if (loadingDepthChart) return;
    
    try {
      setLoadingDepthChart(true);
      console.log(`üï∑Ô∏è Fetching real depth chart for ${teamAbbr} (ESPN + NBA.com backup)`);
      
      // Try ESPN first
      const espnResponse = await fetch(`/api/espn-depth-chart?team=${teamAbbr}`);
      const espnData = await espnResponse.json();
      
      // Check if ESPN data is good (only count position arrays, not metadata)
      const espnPlayerCount = espnData.depthChart ? 
        ['PG', 'SG', 'SF', 'PF', 'C'].reduce((sum, pos) => {
          return sum + (Array.isArray(espnData.depthChart[pos]) ? espnData.depthChart[pos].length : 0);
        }, 0) : 0;
      
      if (espnData.success && espnPlayerCount >= 8) {
        console.log(`‚úÖ Got good ESPN depth chart for ${teamAbbr}: ${espnPlayerCount} players`);
        setRealDepthChart({
          ...espnData.depthChart,
          source: 'ESPN',
          quality: 'primary'
        });
        return;
      }
      
      // ESPN failed or had insufficient data, try NBA.com backup
      console.log(`üîÑ ESPN insufficient (${espnPlayerCount} players), trying NBA.com backup...`);
      
      const nbaResponse = await fetch(`/api/nba-depth-chart?team=${teamAbbr}`);
      const nbaData = await nbaResponse.json();
      
      const nbaPlayerCount = nbaData.depthChart ? 
        ['PG', 'SG', 'SF', 'PF', 'C'].reduce((sum, pos) => {
          return sum + (Array.isArray(nbaData.depthChart[pos]) ? nbaData.depthChart[pos].length : 0);
        }, 0) : 0;
      
      if (nbaData.success && nbaPlayerCount >= 5) {
        console.log(`‚úÖ Got NBA.com backup depth chart for ${teamAbbr}: ${nbaPlayerCount} players`);
        setRealDepthChart({
          ...nbaData.depthChart,
          source: 'NBA.com',
          quality: 'backup'
        });
        return;
      }
      
      // Both sources failed
      console.log(`‚ùå Both ESPN (${espnPlayerCount}) and NBA.com (${nbaPlayerCount}) failed for ${teamAbbr}`);
      setRealDepthChart(null);
      
    } catch (error) {
      console.error('Error fetching depth chart:', error);
      setRealDepthChart(null);
    } finally {
      setLoadingDepthChart(false);
    }
  };
  
  // Create depth chart layout - use real data if available, otherwise return null
  const createDepthChart = (players: any[]) => {
    // If we have real scraped depth chart data, use it
    if (realDepthChart) {
      console.log(`üìä Using real ${realDepthChart.source || 'unknown source'} depth chart data`);
      // Map real depth chart players to roster data to get additional info
      const mappedDepthChart: Record<string, any[]> = {
        PG: [],
        SG: [],
        SF: [],
        PF: [],
        C: []
      };
      
      // Filter out metadata and only process position arrays
      const positions = ['PG', 'SG', 'SF', 'PF', 'C'];
      positions.forEach(position => {
        if (realDepthChart[position] && Array.isArray(realDepthChart[position])) {
          realDepthChart[position].forEach((depthPlayer: any, index: number) => {
            // Try to find this player in the roster data
            const rosterPlayer = players.find(p => 
              p.name && depthPlayer.name && (
                p.name.toLowerCase().includes(depthPlayer.name.toLowerCase()) ||
                depthPlayer.name.toLowerCase().includes(p.name.toLowerCase()) ||
                // Also try first/last name matching
                (p.firstName && p.lastName && 
                  `${p.firstName} ${p.lastName}`.toLowerCase() === depthPlayer.name.toLowerCase())
              )
            );
            
            mappedDepthChart[position].push({
              name: depthPlayer.name,
              depth: index + 1,
              jersey: rosterPlayer?.jersey || 'N/A',
              headshot: rosterPlayer?.headshot || null,
              // Include roster data if found
              ...(rosterPlayer || {})
            });
          });
        }
      });
      
      return mappedDepthChart;
    }
    
    // No real depth chart available
    console.log('‚ùå No real depth chart data available');
    return null;
  };

  // Helper function to get opponent from game
  const getOpponentFromGame = (game: any, playerTeam: string) => {
    // BallDontLie game structure: game.home_team and game.visitor_team objects
    let homeTeamAbbr = 'UNK';
    let awayTeamAbbr = 'UNK';
    
    // Try different ways to get team abbreviations based on BallDontLie structure
    if (game.home_team?.abbreviation) {
      homeTeamAbbr = game.home_team.abbreviation;
    } else if (game.home_team_id) {
      homeTeamAbbr = getTeamAbbreviationById(game.home_team_id);
    }
    
    if (game.visitor_team?.abbreviation) {
      awayTeamAbbr = game.visitor_team.abbreviation;
    } else if (game.visitor_team_id) {
      awayTeamAbbr = getTeamAbbreviationById(game.visitor_team_id);
    }
    
    console.log('√∞≈∏¬è‚Ç¨ Teams - Home:', homeTeamAbbr, 'Away:', awayTeamAbbr, 'PlayerTeam:', playerTeam);
    
    // Return the opponent (not the player's team)
    if (homeTeamAbbr === playerTeam) {
      console.log('√¢≈ì‚Ä¶ Player is home team, opponent is:', awayTeamAbbr);
      return awayTeamAbbr;
    }
    if (awayTeamAbbr === playerTeam) {
      console.log('√¢≈ì‚Ä¶ Player is away team, opponent is:', homeTeamAbbr);
      return homeTeamAbbr;
    }
    
    // If no match found, try to return the opponent (not player's team)
    console.log('√¢≈°¬†√Ø¬∏¬è No team match found for player team:', playerTeam);
    console.log('√¢≈°¬†√Ø¬∏¬è Available teams - Home:', homeTeamAbbr, 'Away:', awayTeamAbbr);
    return homeTeamAbbr !== playerTeam ? homeTeamAbbr : awayTeamAbbr;
  };


  const getOpponentTeam = (currentTeam: string): string => {
    for (const game of todaysGames) {
      if (game.home_team.abbreviation === currentTeam) return game.visitor_team.abbreviation;
      if (game.visitor_team.abbreviation === currentTeam) return game.home_team.abbreviation;
    }
    const fallback: Record<string, string> = {
      LAL: "BOS", BOS: "LAL", GSW: "CLE", CLE: "GSW",
      DEN: "MIA", MIA: "DEN", MIL: "PHX", PHX: "MIL",
      PHI: "DAL", DAL: "PHI", NYK: "LAC", LAC: "NYK",
      BKN: "MIN", MIN: "BKN", CHI: "SAC", SAC: "CHI",
      ATL: "POR", POR: "ATL", CHA: "UTA", UTA: "CHA",
      ORL: "OKC", OKC: "ORL", IND: "SAS", SAS: "IND",
      DET: "HOU", HOU: "DET", TOR: "MEM", MEM: "TOR",
      WAS: "NOP", NOP: "WAS",
    };
    return fallback[currentTeam] || "GSW";
  };

  // Function to check if player's team is playing at home
  const isPlayerTeamHome = (currentTeam: string): boolean => {
    for (const game of todaysGames) {
      if (game.home_team.abbreviation === currentTeam) return true;
      if (game.visitor_team.abbreviation === currentTeam) return false;
    }
    // Default fallback: assume home for consistent display
    return true;
  };

  const currentTeamName =
    NBA_TEAM_NAMES[selectedTeam as keyof typeof NBA_TEAM_NAMES] || "Team";

  const opponentTeam = getOpponentTeam(selectedTeam);
  const opponentTeamName =
    NBA_TEAM_NAMES[opponentTeam as keyof typeof NBA_TEAM_NAMES] || "Opponent";

  const guessPosition = (playerName: string, index: number) => {
    const name = playerName.toLowerCase();
    if (name.includes("curry") || name.includes("lillard") || name.includes("trae") || name.includes("morant") ||
        name.includes("brunson") || name.includes("haliburton") || name.includes("fox") || name.includes("garland") ||
        name.includes("murray")) return "PG";
    if (name.includes("jokic") || name.includes("embiid") || name.includes("gobert") || name.includes("adebayo") ||
        name.includes("towns") || name.includes("allen") || name.includes("wembanyama") || name.includes("holmgren") ||
        name.includes("sabonis")) return "C";
    if (name.includes("giannis") || name.includes("davis") || name.includes("siakam") || name.includes("randle") ||
        name.includes("mobley") || name.includes("barnes")) return "PF";
    if (name.includes("durant") || name.includes("tatum") || name.includes("leonard") || name.includes("george") ||
        name.includes("ingram") || name.includes("bridges")) return "SF";
    const positions = ["PG", "SG", "SF", "PF", "C"];
    return positions[index] || "F";
  };

  const toggleTheme = () => {
    const next = !themeDark;
    setThemeDark(next);
    localStorage.setItem("betting-journal.themeDark", next ? "1" : "0");
  };

  const handleOddsFormatChange = (format: string) => {
    setOddsFormat(format);
    localStorage.setItem('betting-journal.oddsFormat', format);
  };


  /* Build chart series (EST) */
  const filteredRows = useMemo(() => {
    console.log('Processing player logs:', playerLogs.length, 'total games');
    
    if (!playerLogs.length) {
      console.log('No player logs available');
      return [];
    }
    
    // Filter out games where player didn't play (0 minutes)
    const playedGames = playerLogs.filter(log => {
      const minutes = log.min;
      // Parse minutes (can be in format "12:34" or just "12")
      const minValue = typeof minutes === 'string' ? 
        (minutes.includes(':') ? parseInt(minutes.split(':')[0]) : parseFloat(minutes)) : 
        minutes;
      return (minValue || 0) > 0;
    });
    
    console.log('Filtered out DNP games:', playerLogs.length - playedGames.length, 'games removed');
    console.log('Games with minutes played:', playedGames.length);
    
    const currentSeasonRows = normalizeAndSort(playedGames, { season: currentSeason, includePlayoffs: true }); // Current active season
    const allSorted = normalizeAndSort(playedGames, { includePlayoffs: true });
    
    console.log(`Rows by season - ${currentSeason} (${currentSeason === 2025 ? 'LIVE season' : 'completed season'}):`, currentSeasonRows.length);
    
    // Debug: Show what seasons we actually have in the data
    const seasonCounts = playedGames.reduce((acc, game) => {
      acc[game.game.season] = (acc[game.game.season] || 0) + 1;
      return acc;
    }, {} as Record<number, number>);
    console.log('All available seasons in data:', seasonCounts);

    if (selectedTimeFilter === "lastSeason") {
      // If we're in 2025 season, show 2024; otherwise show current season
      const lastSeasonData = currentSeason === 2025 ? 
        normalizeAndSort(playedGames, { season: 2024, includePlayoffs: true }) : 
        currentSeasonRows;
      return lastSeasonData;
    }

    if (selectedTimeFilter === "h2h") {
      // Get the actual opponent team from the matchup panel on the right
      const currentOpponent = opponentTeam;
      
      // Get all games from all seasons (sorted chronologically)
      const allGamesData = normalizeAndSort(playedGames, { includePlayoffs: true });
      
      // Filter for H2H games against the current opponent across all seasons
      const h2hRows = allGamesData.filter((r) => {
        // Use the team from the actual game data (handles trades correctly)
        const playerTeamAtTime = r.team?.abbreviation || getPlayerTeam(selectedPlayer);
        const gameOpponent = getOpponentFromGame(r.game, playerTeamAtTime);
        
        console.log(`H2H Debug - Game ${r.game.id} (Season ${r.game.season}): Player team: ${playerTeamAtTime}, Opponent: ${gameOpponent}, Looking for: ${currentOpponent}`);
        
        // Show games where player faced the current opponent
        return gameOpponent === currentOpponent;
      });
      
      // Take the last 5 games against this opponent (most recent first after sorting)
      const last5H2H = h2hRows.slice(-5);
      
      console.log(`H2H: Found ${h2hRows.length} total games vs ${currentOpponent}, showing last ${last5H2H.length}`);
      return last5H2H;
    }

    let takeN = 10;
    if (selectedTimeFilter === "last5") takeN = 5;
    if (selectedTimeFilter === "last10") takeN = 10;
    if (selectedTimeFilter === "last15") takeN = 15;
    if (selectedTimeFilter === "last20") takeN = 20;

    // Use current season data as the base (live updates when 2025 starts)
    const base = currentSeasonRows.length ? currentSeasonRows : allSorted;
    return base.slice(-takeN);
  }, [playerLogs, selectedTimeFilter, opponentTeam, currentSeason]);

  const chartData = useMemo(() => {
    if (!filteredRows.length) {
      console.log('No filtered rows for chart');
      return [];
    }
    
    const data = filteredRows.map((r, index) => {
      const fullDate = formatEST(r.game.date);
      // Create short date label for chart display
      const shortDate = fullDate.split(',')[0].replace(/2024|2025/g, '').trim() || `Game ${index + 1}`;
      
      // Use the team from the actual game data (handles trades correctly)
      const playerTeamAtTime = r.team?.abbreviation || getPlayerTeam(selectedPlayer);
      console.log('√∞≈∏‚Äú≈† Chart data - Player:', selectedPlayer, 'Team at time:', playerTeamAtTime);
      
      return {
        value: pickStat(r, selectedStat),
        dateLabel: shortDate,
        fullDate: fullDate,
        gameId: r.game.id,
        opponent: getOpponentFromGame(r.game, playerTeamAtTime),
        minutes: r.min
      };
    });
    
    console.log(`Chart data for ${selectedStat}:`, data.length, 'points');
    return data;
  }, [filteredRows, selectedStat, selectedPlayer]);


  // Calculate player analytics
  const playerAnalytics = useMemo(() => {
    if (!playerLogs.length) {
      return {
        seasonAvg: 0,
        lastFiveAvg: 0,
        lastTenAvg: 0,
        consistency: 0,
        overRate: 0,
        trend: 'stable'
      };
    }
    
    // Calculate current season average - updates automatically when 2025 season starts
    const playedGames = playerLogs.filter(log => {
      const minutes = log.min;
      const minValue = typeof minutes === 'string' ? 
        (minutes.includes(':') ? parseInt(minutes.split(':')[0]) : parseFloat(minutes)) : 
        minutes;
      return (minValue || 0) > 0;
    });
    
    const currentSeasonData = normalizeAndSort(playedGames, { season: currentSeason, includePlayoffs: true });
    const seasonValues = currentSeasonData.map(r => pickStat(r, selectedStat));
    const seasonAvg = seasonValues.length > 0 ? seasonValues.reduce((a, b) => a + b, 0) / seasonValues.length : 0;
    
    console.log(`√∞≈∏‚ÄúÀÜ Season avg for ${selectedStat}: ${seasonAvg.toFixed(2)} (${currentSeason === 2025 ? 'LIVE' : 'completed'} season, ${seasonValues.length} games)`);
    
    // Calculate fixed last 5 and last 10 averages from current season data (independent of timeframe filter)
    const last10Games = currentSeasonData.slice(-10);
    const last10Values = last10Games.map(r => pickStat(r, selectedStat));
    const lastTenAvg = last10Values.length > 0 ? last10Values.reduce((a, b) => a + b, 0) / last10Values.length : 0;
    
    const last5Games = currentSeasonData.slice(-5);
    const last5Values = last5Games.map(r => pickStat(r, selectedStat));
    const lastFiveAvg = last5Values.length > 0 ? last5Values.reduce((a, b) => a + b, 0) / last5Values.length : 0;
    
    // Other stats based on current filtered data for chart
    if (!chartData.length) {
      return {
        seasonAvg: Number(seasonAvg.toFixed(1)),
        lastFiveAvg: Number(lastFiveAvg.toFixed(1)),
        lastTenAvg: Number(lastTenAvg.toFixed(1)),
        consistency: 0,
        overRate: 0,
        trend: 'stable'
      };
    }
    
    const values = chartData.map(d => d.value);
    
    const overCount = values.filter(v => v >= selectedLine).length;
    const overRate = (overCount / values.length) * 100;
    
    const variance = values.reduce((acc, val) => acc + Math.pow(val - seasonAvg, 2), 0) / values.length;
    const stdDev = Math.sqrt(variance);
    const consistency = Math.max(0, Math.min(100, 100 - (stdDev / seasonAvg * 100)));
    
    return {
      seasonAvg: Number(seasonAvg.toFixed(1)),
      lastFiveAvg: Number(lastFiveAvg.toFixed(1)),
      lastTenAvg: Number(lastTenAvg.toFixed(1)),
      consistency: Number(consistency.toFixed(0)),
      overRate: Number(overRate.toFixed(0)),
      trend: lastTenAvg > seasonAvg + 1 ? 'trending_up' : lastTenAvg < seasonAvg - 1 ? 'trending_down' : 'stable'
    };
  }, [playerLogs, chartData, selectedStat, selectedLine, currentSeason]);

  // Reset box score page when time filter changes
  useEffect(() => {
    setBoxScorePage(0);
  }, [selectedTimeFilter]);
  
  // Only fetch roster if team actually changed and we don't already have data for this team
  useEffect(() => {
    if (selectedTeam && selectedTeam !== lastFetchedTeam && mounted) {
      console.log(`üîÑ Team changed in useEffect: ${lastFetchedTeam} ‚Üí ${selectedTeam}`);
      fetchTeamRoster(selectedTeam);
    }
  }, [selectedTeam, mounted]);



  if (!mounted) {
    return (
      <div className="min-h-screen bg-white text-slate-900">
        <div className="animate-pulse p-8">
          <div className="h-8 bg-slate-200 rounded mb-4 w-64" />
          <div className="h-4 bg-slate-200 rounded mb-8 w-96" />
        </div>
      </div>
    );
  }

  // --- FIX: compute safe Tailwind classes instead of `text-${...}` dynamic ---
  const textColorClass = themeDark ? "text-white" : "text-slate-900";
  const bgClass = themeDark ? "bg-[#0a0e1a]" : "bg-slate-50";

  return (
    <div className={`min-h-screen overflow-y-auto ${bgClass} ${textColorClass}`}>
      {/* Grid overlay */}
      <div className={`absolute inset-0 opacity-[0.02] ${themeDark ? "bg-slate-800" : "bg-slate-200"}`}>
        <div
          className="h-full w-full"
          style={{
            backgroundImage:
              "linear-gradient(#475569 1px, transparent 1px), linear-gradient(90deg, #475569 1px, transparent 1px)",
            backgroundSize: "20px 20px",
          }}
        />
      </div>

      <Navigation isDark={themeDark} onThemeToggle={toggleTheme} />

      <div className="relative z-10 flex flex-col min-h-screen">
        {/* Header */}
        <div className={`border-b ${themeDark ? "border-slate-800 bg-slate-900/50" : "border-slate-200 bg-white/80"} backdrop-blur-sm`}>
          <div className="flex items-center justify-between px-6 py-4">
            <div className="flex items-center gap-4">
              <Link
                href="/research/nba"
                className={`p-2 rounded-md border transition-all hover:scale-105 ${
                  themeDark
                    ? "border-slate-700 text-slate-400 hover:text-white hover:border-slate-600 bg-slate-800/50"
                    : "border-slate-300 text-slate-600 hover:text-slate-900 hover:border-slate-400 bg-white"
                }`}
              >
                <ArrowLeft className="w-4 h-4" />
              </Link>
              <div className="flex items-center gap-3">
                <div className={`w-2 h-2 rounded-full ${themeDark ? "bg-emerald-400" : "bg-emerald-500"} animate-pulse`} />
                <div>
                  <h1 className={`text-xl font-semibold tracking-tight ${themeDark ? "text-white" : "text-slate-900"}`}>
                    RESEARCH TERMINAL
                  </h1>
                  <p className={`text-xs ${themeDark ? "text-slate-400" : "text-slate-500"} font-mono`}>
                    NBA Analytics Dashboard v2.3 (EST)
                  </p>
                </div>
              </div>
            </div>

            {/* Player Search (center) */}
            <div className="relative flex-1 max-w-2xl mx-6">
              <Search className={`absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 ${themeDark ? "text-slate-500" : "text-slate-400"}`} />
              <input
                type="text"
                placeholder="SEARCH PLAYERS..."
                value={searchQuery}
                onChange={(e) => {
                  setSearchQuery(e.target.value);
                  setShowSuggestions(e.target.value.length >= 2);
                }}
                onKeyDown={(e) => {
                  if (e.key === "Enter" && searchQuery.trim()) {
                    const matches = getPlayerMatches(searchQuery);
                    if (matches.length > 0) {
                      console.log(`üîé Player selected via Enter: ${matches[0]}`);
                      setSelectedPlayer(matches[0]);
                      const encodedPlayer = encodeURIComponent(matches[0]);
                      router.push(`${window.location.pathname}?player=${encodedPlayer}`);
                      setSearchQuery("");
                      setShowSuggestions(false);
                    }
                  } else if (e.key === "Escape") {
                    setSearchQuery("");
                    setShowSuggestions(false);
                  }
                }}
                className={`pl-10 pr-4 py-2 w-full text-sm font-mono border rounded-md focus:outline-none focus:ring-1 transition-all ${
                  themeDark
                    ? "bg-slate-800/50 border-slate-700 text-slate-200 placeholder-slate-500 focus:ring-emerald-500"
                    : "bg-white border-slate-300 text-slate-900 placeholder-slate-400 focus:ring-emerald-500"
                }`}
              />
              {showSuggestions && searchQuery.length >= 2 && (
                <div className={`absolute top-full left-0 right-0 mt-1 border rounded-md shadow-lg z-50 max-h-48 overflow-y-auto ${
                  themeDark ? "bg-slate-800 border-slate-700" : "bg-white border-slate-300"
                }`}>
                  {getPlayerMatches(searchQuery).map((player) => (
                    <button
                      key={player}
                      onClick={() => {
                        console.log(`üîé Player selected: ${player}`);
                        setSelectedPlayer(player);
                        const encodedPlayer = encodeURIComponent(player);
                        router.push(`${window.location.pathname}?player=${encodedPlayer}`);
                        setSearchQuery("");
                        setShowSuggestions(false);
                      }}
                      className={`w-full px-3 py-2 text-left text-sm transition-colors ${
                        themeDark ? "text-slate-200 hover:bg-slate-700" : "text-slate-900 hover:bg-slate-50"
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <span>{player}</span>
                        <span className={`text-xs ${themeDark ? "text-slate-500" : "text-slate-400"}`}>
                          {getPlayerTeam(player)}
                        </span>
                      </div>
                    </button>
                  ))}
                </div>
              )}
            </div>

            {/* Current Player Display & Search */}
            <div className="flex items-center gap-6">
              <div className={`px-4 py-2 border rounded-md ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-300 bg-white"}`}>
                <div className={`text-xs uppercase tracking-wide font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>ANALYZING:</div>
                <div className={`text-sm font-bold ${themeDark ? "text-emerald-400" : "text-emerald-600"}`}>
                  {selectedPlayer.toUpperCase()}
                </div>
              </div>
              
              
              {/* status */}
              <div className="flex items-center gap-2">
                <div className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>STATUS:</div>
                <div className={`text-xs font-mono font-semibold ${themeDark ? "text-emerald-400" : "text-emerald-600"}`}>LIVE</div>
              </div>
            </div>
          </div>
        </div>


        {/* main layout */}
        <div className="flex-1 flex flex-col lg:flex-row gap-6 px-4 lg:px-6 py-4 pb-8">
          {/* left pane */}
          <div className="w-full lg:w-80 flex-shrink-0 -mt-4">
            <div className={`rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
              <div className={`px-3 py-2 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
                <div className="flex items-center gap-2">
                  <div className={`w-2 h-2 rounded-full ${themeDark ? "bg-emerald-400" : "bg-emerald-500"}`} />
                  <div className="flex items-center gap-2">
                    <h3 className={`font-semibold text-sm font-mono tracking-wider ${themeDark ? "text-white" : "text-slate-900"}`}>
                      INDIVIDUAL PLAYER STATS
                    </h3>
                    <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                      {(() => {
                        if (selectedStat === 'points' || selectedStat === 'pts') {
                          return 'SCORING';
                        } else if (selectedStat === 'assists' || selectedStat === 'ast') {
                          return 'PLAYMAKING';
                        } else if (selectedStat === 'rebounds' || selectedStat === 'reb' || selectedStat === 'total_rb') {
                          return 'REBOUNDING';
                        } else if (selectedStat === 'steals' || selectedStat === 'stl') {
                          return 'DEFENSE';
                        } else if (selectedStat === 'blocks' || selectedStat === 'blk') {
                          return 'DEFENSE';
                        } else if (selectedStat === '3pm' || selectedStat === 'fg3m') {
                          return 'SHOOTING';
                        } else {
                          return 'ADVANCED';
                        }
                      })()}
                    </span>
                    {currentSeason === 2025 && (
                      <span className="px-1.5 py-0.5 text-xs font-bold bg-red-500 text-white rounded animate-pulse">
                        LIVE
                      </span>
                    )}
                  </div>
                </div>
              </div>

              <div className="p-3 space-y-1.5">
                {/* Dynamic stats based on selectedStat filter */}
                {(() => {
                  // Stat performance thresholds for color coding
                  const getStatColor = (statName: string, value: number): string => {
                    const thresholds: { [key: string]: { good: number; bad: number; higherIsBetter: boolean } } = {
                      'PIE': { good: 0.120, bad: 0.080, higherIsBetter: true },
                      'Usage Rate': { good: 0.25, bad: 0.15, higherIsBetter: true }, // API returns as decimal
                      'Pace': { good: 102, bad: 98, higherIsBetter: true },
                      'True Shooting': { good: 0.58, bad: 0.52, higherIsBetter: true }, // API returns as decimal (0.58 = 58%)
                      'Effective FG%': { good: 0.55, bad: 0.50, higherIsBetter: true }, // API returns as decimal
                      'Off Rating': { good: 115, bad: 105, higherIsBetter: true },
                      'Def Rating': { good: 108, bad: 118, higherIsBetter: false }, // Lower is better
                      'Assist %': { good: 0.25, bad: 0.15, higherIsBetter: true }, // API returns as decimal
                      'AST/TO Ratio': { good: 2.5, bad: 1.5, higherIsBetter: true },
                      'Turnover Ratio': { good: 0.12, bad: 0.18, higherIsBetter: false }, // API returns as decimal, lower is better
                      'Total Reb %': { good: 0.15, bad: 0.08, higherIsBetter: true }, // API returns as decimal
                      'Def Reb %': { good: 0.25, bad: 0.15, higherIsBetter: true }, // API returns as decimal
                      'Net Rating': { good: 5, bad: -5, higherIsBetter: true },
                      'Clutch Usage': { good: 0.25, bad: 0.15, higherIsBetter: true }, // API returns as decimal
                      'Clutch TS%': { good: 0.55, bad: 0.45, higherIsBetter: true }, // API returns as decimal
                      'Clutch PPG': { good: 3, bad: 1, higherIsBetter: true }
                    };
                    
                    const threshold = thresholds[statName];
                    if (!threshold) return themeDark ? 'text-white' : 'text-slate-900'; // Default color
                    
                    const { good, bad, higherIsBetter } = threshold;
                    
                    if (higherIsBetter) {
                      if (value >= good) return 'text-green-500'; // Good (green)
                      if (value <= bad) return 'text-red-500';   // Bad (red)
                      return 'text-orange-500';                 // Mid (orange)
                    } else {
                      if (value <= good) return 'text-green-500'; // Good (green) - lower is better
                      if (value >= bad) return 'text-red-500';    // Bad (red) - higher is bad
                      return 'text-orange-500';                  // Mid (orange)
                    }
                  };

                  // Stat definitions for tooltips
                  const statDefinitions: { [key: string]: string } = {
                    'PIE': 'Player Impact Estimate - Overall impact metric combining positive & negative contributions. Higher is better (NBA avg ~0.100).',
                    'Usage Rate': 'Percentage of team possessions used by player while on court. Measures offensive load (NBA avg ~20%).',
                    'Pace': 'Estimated possessions per 48 minutes when player is on court. Higher pace = more possessions.',
                    'True Shooting': 'Shooting efficiency including 2s, 3s & free throws. Formula: PTS / (2 √É‚Äî (FGA + 0.44 √É‚Äî FTA)). NBA avg ~56%.',
                    'Effective FG%': 'Field goal percentage adjusted for 3-point value. Formula: (FGM + 0.5 √É‚Äî 3PM) / FGA. NBA avg ~53%.',
                    'Off Rating': 'Points scored per 100 possessions when player is on court. Higher is better (NBA avg ~110-115).',
                    'Def Rating': 'Points allowed per 100 possessions when player is on court. Lower is better (NBA avg ~110-115).',
                    'Assist %': 'Percentage of teammate field goals assisted while player is on court. Measures playmaking impact.',
                    'AST/TO Ratio': 'Assists per turnover. Measures ball security & playmaking efficiency. Higher is better (2+ is good).',
                    'Turnover Ratio': 'Turnovers per 100 possessions used. Lower is better. Measures ball security.',
                    'Total Reb %': 'Percentage of available rebounds grabbed while on court. Measures rebounding impact.',
                    'Def Reb %': 'Percentage of available defensive rebounds grabbed while on court.',
                    'Net Rating': 'Point differential per 100 possessions (Off Rating - Def Rating). Positive is better.',
                    'Clutch Usage': 'Usage rate in clutch situations (last 5 min, score within 5 points).',
                    'Clutch TS%': 'True shooting percentage in clutch situations. Measures clutch shooting efficiency.',
                    'Clutch PPG': 'Points per game in clutch situations only.'
                  };

                  // Tooltip component
                  const StatTooltip = ({ statName, value }: { statName: string; value: React.ReactNode }) => {
                    const [showTooltip, setShowTooltip] = useState(false);
                    const definition = statDefinitions[statName];
                    
                    if (!definition) {
                      return (
                        <div className="flex items-center justify-between w-full">
                          <span className={`text-xs ${themeDark ? "text-white" : "text-black"}`}>{statName}</span>
                          {value}
                        </div>
                      );
                    }
                    
                    return (
                      <div className="flex items-center justify-between w-full">
                        <div className="flex items-center gap-1 relative">
                          <span className={`text-xs ${themeDark ? "text-white" : "text-black"}`}>{statName}</span>
                          <button
                            onMouseEnter={() => setShowTooltip(true)}
                            onMouseLeave={() => setShowTooltip(false)}
                            className={`w-3 h-3 rounded-full text-xs font-bold flex items-center justify-center ${
                              themeDark ? "bg-slate-600 text-white hover:bg-slate-500" : "bg-slate-300 text-black hover:bg-slate-400"
                            }`}
                          >
                            ?
                          </button>
                          {showTooltip && (
                            <div className={`absolute z-50 left-0 bottom-6 w-64 p-2 text-xs rounded-lg border shadow-lg ${
                              themeDark ? "bg-slate-800 border-slate-600 text-white" : "bg-white border-slate-300 text-black"
                            }`}>
                              {definition}
                            </div>
                          )}
                        </div>
                        {value}
                      </div>
                    );
                  };

                  // Define stat groups - PIE, Usage Rate, and Pace always at top
                  const scoringStats = [
                    { label: 'PIE', value: advancedStats?.player_efficiency_rating, format: (v: number) => v.toFixed(3) },
                    { label: 'Usage Rate', value: advancedStats?.usage_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Pace', value: advancedStats?.pace, format: (v: number) => v.toFixed(1) },
                    { label: 'True Shooting', value: advancedStats?.true_shooting_percentage, format: (v: number) => {
                      // Show N/A for impossible values (API data error)
                      if (v > 1) return 'N/A';
                      return `${(v * 100).toFixed(1)}%`;
                    }},
                    { label: 'Effective FG%', value: advancedStats?.effective_field_goal_percentage, format: (v: number) => {
                      // Show N/A for impossible values (API data error) 
                      if (v > 1) return 'N/A';
                      return `${(v * 100).toFixed(1)}%`;
                    }},
                    { label: 'Off Rating', value: advancedStats?.offensive_rating, format: (v: number) => v.toFixed(1) },
                    { label: 'Clutch Usage', value: clutchStats?.clutch_usage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Clutch TS%', value: clutchStats?.clutch_ts, format: (v: number) => {
                      // Show N/A for impossible values (API data error)
                      if (v > 1) return 'N/A';
                      return `${(v * 100).toFixed(1)}%`;
                    }}
                  ];

                  const assistStats = [
                    { label: 'PIE', value: advancedStats?.player_efficiency_rating, format: (v: number) => v.toFixed(3) },
                    { label: 'Usage Rate', value: advancedStats?.usage_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Pace', value: advancedStats?.pace, format: (v: number) => v.toFixed(1) },
                    { label: 'Assist %', value: advancedStats?.assist_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'AST/TO Ratio', value: advancedStats?.assist_to_turnover_ratio, format: (v: number) => v.toFixed(1) },
                    { label: 'Turnover Ratio', value: advancedStats?.turnover_ratio, format: (v: number) => v.toFixed(2) },
                    { label: 'Off Rating', value: advancedStats?.offensive_rating, format: (v: number) => v.toFixed(1) },
                    { label: 'Net Rating', value: advancedStats?.net_rating, format: (v: number) => v.toFixed(1) }
                  ];

                  const reboundStats = [
                    { label: 'PIE', value: advancedStats?.player_efficiency_rating, format: (v: number) => v.toFixed(3) },
                    { label: 'Usage Rate', value: advancedStats?.usage_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Pace', value: advancedStats?.pace, format: (v: number) => v.toFixed(1) },
                    { label: 'Total Reb %', value: advancedStats?.rebound_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Def Reb %', value: advancedStats?.defensive_rebound_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Def Rating', value: advancedStats?.defensive_rating, format: (v: number) => v.toFixed(1) },
                    { label: 'Off Rating', value: advancedStats?.offensive_rating, format: (v: number) => v.toFixed(1) },
                    { label: 'Net Rating', value: advancedStats?.net_rating, format: (v: number) => v.toFixed(1) }
                  ];

                  const generalStats = [
                    { label: 'PIE', value: advancedStats?.player_efficiency_rating, format: (v: number) => v.toFixed(3) },
                    { label: 'Usage Rate', value: advancedStats?.usage_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Pace', value: advancedStats?.pace, format: (v: number) => v.toFixed(1) },
                    { label: 'True Shooting', value: advancedStats?.true_shooting_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Off Rating', value: advancedStats?.offensive_rating, format: (v: number) => v.toFixed(1) },
                    { label: 'Def Rating', value: advancedStats?.defensive_rating, format: (v: number) => v.toFixed(1) },
                    { label: 'Assist %', value: advancedStats?.assist_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Total Reb %', value: advancedStats?.rebound_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'Effective FG%', value: advancedStats?.effective_field_goal_percentage, format: (v: number) => `${(v * 100).toFixed(1)}%` },
                    { label: 'AST/TO Ratio', value: advancedStats?.assist_to_turnover_ratio, format: (v: number) => v.toFixed(1) },
                    { label: 'Net Rating', value: advancedStats?.net_rating, format: (v: number) => v.toFixed(1) }
                  ];

                  // Select stats based on current filter
                  let currentStats = generalStats;
                  if (selectedStat === 'points' || selectedStat === 'pts') {
                    currentStats = scoringStats;
                  } else if (selectedStat === 'assists' || selectedStat === 'ast') {
                    currentStats = assistStats;
                  } else if (selectedStat === 'rebounds' || selectedStat === 'reb' || selectedStat === 'total_rb') {
                    currentStats = reboundStats;
                  }

                  return currentStats.map((stat, index) => (
                    <div key={index} className="">
                      <StatTooltip 
                        statName={stat.label}
                        value={
                          <span className={`text-sm font-bold ${
                            loadingAdvancedStats 
                              ? (themeDark ? "text-white" : "text-black")
                              : stat.value 
                                ? (() => {
                                    const formattedValue = stat.format(stat.value);
                                    // Show N/A in grey color
                                    if (formattedValue === 'N/A') {
                                      return themeDark ? "text-slate-400" : "text-slate-500";
                                    }
                                    return getStatColor(stat.label, stat.value);
                                  })()
                                : (themeDark ? "text-white" : "text-black")
                          }`}>
                            {loadingAdvancedStats ? '...' : stat.value ? stat.format(stat.value) : 'N/A'}
                          </span>
                        }
                      />
                    </div>
                  ));
                })()}
              </div>
            </div>
            
            {/* Team Matchup Stats */}
            <div className={`mt-4 rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
              <div className={`px-3 py-2 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
                <div className="flex items-center gap-2">
                  <div className={`w-2 h-2 rounded-full ${themeDark ? "bg-blue-400" : "bg-blue-500"}`} />
                  <h3 className={`font-semibold text-sm font-mono tracking-wider ${themeDark ? "text-white" : "text-slate-900"}`}>
                    TEAM MATCHUP
                  </h3>
                  <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                    {selectedTeam} vs {opponentTeam}
                  </span>
                </div>
              </div>
              
              <div className="p-4">
                {/* Table Header */}
                <div className={`grid grid-cols-3 gap-4 pb-3 border-b ${themeDark ? "border-slate-700" : "border-slate-200"}`}>
                  <div className={`text-xs font-mono font-bold uppercase tracking-wider ${themeDark ? "text-slate-400" : "text-slate-500"}`}>METRIC</div>
                  <div className={`text-xs font-mono font-bold uppercase tracking-wider text-center ${themeDark ? "text-slate-400" : "text-slate-500"}`}>{selectedTeam}</div>
                  <div className={`text-xs font-mono font-bold uppercase tracking-wider text-center ${themeDark ? "text-slate-400" : "text-slate-500"}`}>{opponentTeam}</div>
                </div>
                
                {/* Offensive Rating vs Defensive Rating */}
                <div className="grid grid-cols-3 gap-4 py-3">
                  <div className={`text-sm font-medium ${themeDark ? "text-white" : "text-black"}`}>
                    OFF VS DEF RATINGS
                  </div>
                  <div className="text-center">
                    <div className={`text-xs font-mono mb-1 ${themeDark ? "text-white" : "text-black"}`}>OFFENSE</div>
                    <div className={`text-base font-bold ${getRankColor(getTeamRank(selectedTeam, 'offensive'), 'offensive')}`}>
                      {getOrdinalSuffix(getTeamRank(selectedTeam, 'offensive'))}
                    </div>
                    <div className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                      {getTeamRating(selectedTeam, 'offensive').toFixed(1)}
                    </div>
                  </div>
                  <div className="text-center">
                    <div className={`text-xs font-mono mb-1 ${themeDark ? "text-white" : "text-black"}`}>DEFENSE</div>
                    <div className={`text-base font-bold ${getRankColor(getTeamRank(opponentTeam, 'defensive'), 'defensive')}`}>
                      {getOrdinalSuffix(getTeamRank(opponentTeam, 'defensive'))}
                    </div>
                    <div className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                      {getTeamRating(opponentTeam, 'defensive').toFixed(1)}
                    </div>
                  </div>
                </div>
                
                {/* Net Rating Comparison */}
                <div className={`grid grid-cols-3 gap-4 py-3 border-t ${themeDark ? "border-slate-700/50" : "border-slate-200/50"}`}>
                  <div className={`text-sm font-medium ${themeDark ? "text-white" : "text-black"}`}>
                    Net Rating
                  </div>
                  <div className="text-center">
                    <div className={`text-xs font-mono mb-1 ${themeDark ? "text-white" : "text-black"}`}>NET RTG</div>
                    <div className={`text-base font-bold ${getRankColor(getTeamRank(selectedTeam, 'net'), 'net')}`}>
                      {getOrdinalSuffix(getTeamRank(selectedTeam, 'net'))}
                    </div>
                    <div className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                      {getTeamRating(selectedTeam, 'net') > 0 ? '+' : ''}{getTeamRating(selectedTeam, 'net').toFixed(1)}
                    </div>
                  </div>
                  <div className="text-center">
                    <div className={`text-xs font-mono mb-1 ${themeDark ? "text-white" : "text-black"}`}>NET RTG</div>
                    <div className={`text-base font-bold ${getRankColor(getTeamRank(opponentTeam, 'net'), 'opponent_net')}`}>
                      {getOrdinalSuffix(getTeamRank(opponentTeam, 'net'))}
                    </div>
                    <div className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                      {getTeamRating(opponentTeam, 'net') > 0 ? '+' : ''}{getTeamRating(opponentTeam, 'net').toFixed(1)}
                    </div>
                  </div>
                </div>
                
                {/* Pace Comparison */}
                <div className={`grid grid-cols-3 gap-4 py-3 border-t ${themeDark ? "border-slate-700/50" : "border-slate-200/50"}`}>
                  <div className={`text-sm font-medium ${themeDark ? "text-white" : "text-black"}`}>
                    Pace
                  </div>
                  <div className="text-center">
                    <div className={`text-xs font-mono mb-1 ${themeDark ? "text-white" : "text-black"}`}>PACE</div>
                    <div className={`text-base font-bold ${getRankColor(getPaceRank(selectedTeam), 'pace')}`}>
                      {getOrdinalSuffix(getPaceRank(selectedTeam))}
                    </div>
                    <div className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                      {getTeamPace(selectedTeam).toFixed(1)}
                    </div>
                  </div>
                  <div className="text-center">
                    <div className={`text-xs font-mono mb-1 ${themeDark ? "text-white" : "text-black"}`}>PACE</div>
                    <div className={`text-base font-bold ${getRankColor(getPaceRank(opponentTeam), 'pace')}`}>
                      {getOrdinalSuffix(getPaceRank(opponentTeam))}
                    </div>
                    <div className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                      {getTeamPace(opponentTeam).toFixed(1)}
                    </div>
                  </div>
                </div>
                
                {/* Rebound % Comparison */}
                <div className={`grid grid-cols-3 gap-4 py-3 border-t ${themeDark ? "border-slate-700/50" : "border-slate-200/50"}`}>
                  <div className={`text-sm font-medium ${themeDark ? "text-white" : "text-black"}`}>
                    Rebound %
                  </div>
                  <div className="text-center">
                    <div className={`text-xs font-mono mb-1 ${themeDark ? "text-white" : "text-black"}`}>REB %</div>
                    <div className={`text-base font-bold ${getRankColor(getReboundRank(selectedTeam), 'rebound')}`}>
                      {getOrdinalSuffix(getReboundRank(selectedTeam))}
                    </div>
                    <div className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                      {getTeamReboundPct(selectedTeam).toFixed(1)}%
                    </div>
                  </div>
                  <div className="text-center">
                    <div className={`text-xs font-mono mb-1 ${themeDark ? "text-white" : "text-black"}`}>REB %</div>
                    <div className={`text-base font-bold ${getRankColor(getReboundRank(opponentTeam), 'opponent_rebound')}`}>
                      {getOrdinalSuffix(getReboundRank(opponentTeam))}
                    </div>
                    <div className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                      {getTeamReboundPct(opponentTeam).toFixed(1)}%
                    </div>
                  </div>
                </div>
                
                {/* Color legend for betting guidance */}
                <div className={`mt-4 pt-3 border-t ${themeDark ? "border-slate-700" : "border-slate-200"}`}>
                  <div className="flex items-center justify-center gap-6 mb-3">
                    <div className="flex items-center gap-2">
                      <div className="w-3 h-3 rounded-full bg-green-500"></div>
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                        BETTER FOR OVERS
                      </span>
                    </div>
                    <div className="flex items-center gap-2">
                      <div className="w-3 h-3 rounded-full bg-red-500"></div>
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                        BETTER FOR UNDERS
                      </span>
                    </div>
                  </div>
                </div>
                
                {/* Season status indicator */}
                <div className={`pt-3 border-t ${themeDark ? "border-slate-700" : "border-slate-200"}`}>
                  <div className="text-center space-y-1">
                    <div className="flex items-center justify-center gap-2">
                      <div className="w-2 h-2 rounded-full bg-amber-500"></div>
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                        RANKINGS FROM LAST SEASON
                      </span>
                    </div>
                    <div className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                      WILL UPDATE WHEN NEW SEASON STARTS
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* center chart */}
          <div className="flex-1 w-full lg:flex-1 -mt-4">
            <div 
              className={`rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"} flex flex-col overflow-hidden`}
              style={{ height: 825 }}
            >
              <div className={`px-4 py-3 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
                  <div className="flex items-start justify-between">
                    <div className="flex items-center gap-6">
                      <div className="flex items-center gap-3">
                        <div className={`w-2 h-2 rounded-full ${themeDark ? "bg-emerald-400" : "bg-emerald-500"} animate-pulse`} />
                        <div className="mt-5">
                          <h3 className={`font-semibold text-lg font-mono tracking-wide ${themeDark ? "text-white" : "text-slate-900"}`}>
                            {selectedPlayer.toUpperCase()}
                          </h3>
                          <p className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>
                            Performance Analytics ‚Ä¢ {selectedTeam}
                          </p>
                          {/* Team Logos - Away @ Home format */}
                          <div className="flex items-center justify-start gap-2 mt-2">
                            {(() => {
                              const playerTeam = getPlayerTeam(selectedPlayer);
                              const isHome = isPlayerTeamHome(playerTeam);
                              const awayTeam = isHome ? opponentTeam : playerTeam;
                              const homeTeam = isHome ? playerTeam : opponentTeam;
                              
                              return (
                                <>
                                  <img 
                                    src={`https://a.espncdn.com/i/teamlogos/nba/500/${getESPNLogoName(awayTeam)}.png`}
                                    alt={`${awayTeam} logo`}
                                    className="w-7 h-7"
                                    onError={(e) => {
                                      const target = e.target as HTMLImageElement;
                                      target.src = `https://cdn.espn.com/combiner/i?img=/i/teamlogos/nba/500/${getESPNLogoName(awayTeam)}.png&h=40&w=40`;
                                    }}
                                  />
                                  <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>@</span>
                                  <img 
                                    src={`https://a.espncdn.com/i/teamlogos/nba/500/${getESPNLogoName(homeTeam)}.png`}
                                    alt={`${homeTeam} logo`}
                                    className="w-7 h-7"
                                    onError={(e) => {
                                      const target = e.target as HTMLImageElement;
                                      target.src = `https://cdn.espn.com/combiner/i?img=/i/teamlogos/nba/500/${getESPNLogoName(homeTeam)}.png&h=40&w=40`;
                                    }}
                                  />
                                </>
                              );
                            })()
                            }
                          </div>
                        </div>
                      </div>
                      
                      {/* Player Stats - Inline with name */}
                      <div className="space-y-2 font-mono mt-10">
                        <div className={`text-sm ${themeDark ? "text-white" : "text-black"}`}>
                          AVERAGE: <span className={`font-bold ${themeDark ? "text-white" : "text-black"}`}>{playerAnalytics.seasonAvg}</span>
                        </div>
                        <div className={`text-sm ${themeDark ? "text-white" : "text-black"}`}>
                          LAST TEN AVERAGE: <span className="font-bold text-emerald-500">{playerAnalytics.lastTenAvg}</span>
                        </div>
                        <div className={`text-sm ${themeDark ? "text-white" : "text-black"}`}>
                          OVER RATE: <span className="font-bold text-emerald-500">{playerAnalytics.overRate}%</span>
                        </div>
                        <div className={`text-sm ${themeDark ? "text-white" : "text-black"}`}>
                          CONSISTENCY: <span className={`font-bold ${themeDark ? "text-white" : "text-black"}`}>{playerAnalytics.consistency}%</span>
                        </div>
                      </div>
                    </div>

                  <div className="max-w-md">
                    {/* Core Stats */}
                    <div className="mb-2">
                      <div className={`text-[9px] font-mono font-bold mb-1 tracking-wider ${themeDark ? "text-white" : "text-black"}`}>CORE</div>
                      <div className="flex gap-1 flex-wrap">
                        {["points", "rebounds", "assists", "fg3m"].map((stat) => (
                          <button
                            key={stat}
                            onClick={() => {
                              console.log(`üìä Switching to stat: ${stat}`);
                              setSelectedStat(stat);
                            }}
                            className={`px-2.5 py-1.5 rounded text-[11px] font-mono font-bold transition-all border ${
                              selectedStat === stat
                                ? themeDark
                                  ? "bg-purple-600 text-white border-purple-500"
                                  : "bg-purple-500 text-white border-purple-400"
                                : themeDark
                                ? "border-slate-600/50 text-white hover:bg-slate-700/50"
                                : "border-slate-200 text-black hover:bg-slate-50"
                            }`}
                          >
                            {stat === "fg3m" ? "3PM" : stat.charAt(0).toUpperCase() + stat.slice(1)}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Shooting Stats */}
                    <div className="mb-2">
                      <div className={`text-[9px] font-mono font-bold mb-1 tracking-wider ${themeDark ? "text-white" : "text-black"}`}>SHOOTING</div>
                      <div className="flex gap-1 flex-wrap">
                        {[
                          { stat: "fgm", label: "FGM" },
                          { stat: "fga", label: "FGA" },
                          { stat: "fg3a", label: "3PA" },
                          { stat: "ftm", label: "FTM" },
                          { stat: "fta", label: "FTA" }
                        ].map(({ stat, label }) => (
                          <button
                            key={stat}
                            onClick={() => {
                              console.log(`üéØ Switching to shooting stat: ${stat}`);
                              setSelectedStat(stat);
                            }}
                            className={`px-2.5 py-1.5 rounded text-[11px] font-mono font-bold transition-all border ${
                              selectedStat === stat
                                ? themeDark
                                  ? "bg-purple-600 text-white border-purple-500"
                                  : "bg-purple-500 text-white border-purple-400"
                                : themeDark
                                ? "border-slate-600/50 text-white hover:bg-slate-700/50"
                                : "border-slate-200 text-black hover:bg-slate-50"
                            }`}
                          >
                            {label}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Other Stats */}
                    <div>
                      <div className={`text-[9px] font-mono font-bold mb-1 tracking-wider ${themeDark ? "text-white" : "text-black"}`}>OTHER</div>
                      <div className="flex gap-1 flex-wrap">
                        {[
                          { stat: "min", label: "MIN" },
                          { stat: "steals", label: "STL" },
                          { stat: "blocks", label: "BLK" },
                          { stat: "oreb", label: "OREB" },
                          { stat: "dreb", label: "DREB" },
                          { stat: "pf", label: "PF" },
                          { stat: "turnovers", label: "TO" }
                        ].map(({ stat, label }) => (
                          <button
                            key={stat}
                            onClick={() => {
                              console.log(`‚è±Ô∏è Switching to other stat: ${stat}`);
                              setSelectedStat(stat);
                            }}
                            className={`px-2.5 py-1.5 rounded text-[11px] font-mono font-bold transition-all border ${
                              selectedStat === stat
                                ? themeDark
                                  ? "bg-purple-600 text-white border-purple-500"
                                  : "bg-purple-500 text-white border-purple-400"
                                : themeDark
                                ? "border-slate-600/50 text-white hover:bg-slate-700/50"
                                : "border-slate-200 text-black hover:bg-slate-50"
                            }`}
                          >
                            {label}
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Chart Area with Controls */}
              <div className="flex-1 min-h-0">
                <div className={`h-full border flex flex-col min-h-0 ${themeDark ? "border-slate-700 border-opacity-50 bg-slate-900 bg-opacity-30" : "border-slate-200 bg-slate-50 bg-opacity-50"}`}>
                  {/* controls row */}
                  <div className={`p-3 border-b font-mono ${themeDark ? "border-slate-700 border-opacity-50 bg-slate-800 bg-opacity-30" : "border-slate-200 bg-slate-100 bg-opacity-50"}`}>
                    <div className="flex items-center justify-between">
                      {/* line control */}
                      <div className="flex items-center gap-3">
                        <div className={`text-xs uppercase tracking-wide font-mono font-bold ${themeDark ? "text-white" : "text-black"}`}>LINE:</div>
                        <div className="flex items-center gap-2">
                          <button
                            onClick={() => setSelectedLine(Math.max(Number(selectedLine) - 0.5, 0))}
                            className={`w-7 h-7 rounded border text-xs font-bold transition-all ${
                              themeDark
                                ? "border-slate-600 text-white hover:bg-slate-700"
                                : "border-slate-300 text-black hover:bg-slate-100"
                            }`}
                          >
                            -
                          </button>
                          <div
                            className={`px-2 py-1 border rounded text-sm font-bold min-w-[50px] text-center ${
                              themeDark ? "bg-slate-800 border-slate-600 text-blue-400" : "bg-white border-slate-300 text-blue-600"
                            }`}
                          >
                            {(() => {
                              const line = Number(selectedLine || 0.5);
                              // Betting lines always end in .5
                              return `${line.toFixed(1)}`;
                            })()}
                          </div>
                          <button
                            onClick={() => setSelectedLine(Number(selectedLine) + 0.5)}
                            className={`w-7 h-7 rounded border text-xs font-bold transition-all ${
                              themeDark
                                ? "border-slate-600 text-white hover:bg-slate-700"
                                : "border-slate-300 text-black hover:bg-slate-100"
                            }`}
                          >
                            +
                          </button>
                        </div>
                      </div>

                      {/* time filters */}
                      <div className="flex items-center gap-3">
                        <div className={`text-xs uppercase tracking-wide font-mono font-bold ${themeDark ? "text-white" : "text-black"}`}>TIMEFRAME:</div>
                        <div className="flex items-center gap-1">
                          {[
                            { key: "last5", label: "L5" },
                            { key: "last10", label: "L10" },
                            { key: "last15", label: "L15" },
                            { key: "last20", label: "L20" },
                            { key: "last_season", label: "LAST SEASON" },
                            { key: "h2h", label: "H2H" }
                          ].map((f) => (
                            <button
                              key={f.key}
                              onClick={() => setSelectedTimeFilter(f.key as any)}
                              className={`px-2.5 py-1.5 rounded text-[11px] font-mono font-bold transition-all border ${
                                selectedTimeFilter === f.key
                                  ? themeDark
                                    ? "bg-purple-600 text-white border-purple-500"
                                    : "bg-purple-500 text-white border-purple-400"
                              : themeDark
                              ? "border-slate-600/50 text-white hover:bg-slate-700/50"
                              : "border-slate-200 text-black hover:bg-slate-50"
                              }`}
                            >
                              {f.label}
                            </button>
                          ))}
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* chart area */}
                  <div className="flex-1 min-h-0">
                    <div className={`h-full border relative ${themeDark ? "border-slate-700 border-opacity-30 bg-slate-800 bg-opacity-10" : "border-slate-300 border-opacity-50 bg-white bg-opacity-30"}`}>
                      {!chartData.length ? (
                        <div className="absolute inset-0 flex items-center justify-center">
                          <div className={`text-center ${themeDark ? 'text-slate-400' : 'text-slate-600'}`}>
                            {loadingLogs ? (
                              <>
                                <div className="animate-spin w-8 h-8 border-2 border-purple-500 border-t-transparent rounded-full mx-auto mb-4" />
                                <div className="text-lg font-bold mb-2">Loading Player Data</div>
                                <div className="text-sm mb-2">Fetching {selectedStat} stats for {selectedPlayer}</div>
                                <div className="text-xs">Please wait...</div>
                              </>
                            ) : (
                              <>
                                <div className="text-lg font-bold mb-2">No Chart Data</div>
                                <div className="text-sm mb-2">No {selectedStat} data for {selectedPlayer}</div>
                                <div className="text-xs">Player logs: {playerLogs.length}</div>
                                <button 
                                  onClick={() => {
                                    failedLookupCache.delete(selectedPlayer);
                                    setSelectedPlayer(selectedPlayer + ' '); // Force re-fetch
                                    setSelectedPlayer(selectedPlayer.trim());
                                  }}
                                  className={`mt-4 px-4 py-2 rounded text-sm font-medium transition-colors ${
                                    themeDark 
                                      ? 'bg-purple-600 hover:bg-purple-700 text-white'
                                      : 'bg-purple-500 hover:bg-purple-600 text-white'
                                  }`}
                                >
                                  Retry
                                </button>
                              </>
                            )}
                          </div>
                        </div>
                      ) : (
                        <div className="h-full p-2">
                          <ResponsiveContainer width="100%" height="100%">
                            <BarChart
                              data={chartData}
                              margin={{ top: 20, right: 30, left: 10, bottom: 5 }}
                              isAnimationActive={false}
                            >
                              <CartesianGrid 
                                strokeDasharray="0.5 4" 
                                opacity={0.12}
                                stroke={themeDark ? '#475569' : '#cbd5e1'}
                                strokeWidth={0.3}
                              />
                              <XAxis 
                                dataKey="dateLabel" 
                                angle={-45}
                                textAnchor="end"
                                height={80}
                                tick={{ 
                                  fontSize: (() => {
                                    const gameCount = chartData.length;
                                    if (gameCount <= 5) return 14; // L5 - largest
                                    if (gameCount <= 10) return 12; // L10 - medium-large
                                    if (gameCount <= 15) return 11; // L15 - medium
                                    if (gameCount <= 20) return 10; // L20 - default
                                    return 9; // Last season or large datasets - smaller
                                  })(),
                                  fill: themeDark ? '#38bdf8' : '#0ea5e9' 
                                }}
                                interval={0}
                              />
                              <YAxis 
                                tick={{ fontSize: 10, fill: themeDark ? '#94a3b8' : '#64748b' }}
                                domain={(() => {
                                  const maxValue = Math.max(...chartData.map(d => d.value));
                                  const tickInterval = (() => {
                                    if (selectedStat === 'points') return 5;
                                    if (['rebounds', 'assists'].includes(selectedStat)) return 2;
                                    if (['steals', 'blocks', 'turnovers', 'oreb', 'dreb'].includes(selectedStat)) return 1;
                                    if (['fgm', 'fga', 'fg3m', 'fg3a', 'ftm', 'fta', 'pf'].includes(selectedStat)) return 1;
                                    if (['fg_pct', 'fg3_pct', 'ft_pct'].includes(selectedStat)) return 0.1;
                                    if (selectedStat === 'min') return 5;
                                    return 1;
                                  })();
                                  const maxTick = Math.ceil(maxValue / tickInterval) * tickInterval + (maxValue % tickInterval === 0 ? tickInterval : 0);
                                  return [0, maxTick];
                                })()}
                                ticks={(() => {
                                  const maxValue = Math.max(...chartData.map(d => d.value));
                                  const tickInterval = (() => {
                                    if (selectedStat === 'points') return 5;
                                    if (['rebounds', 'assists'].includes(selectedStat)) return 2;
                                    if (['steals', 'blocks', 'turnovers', 'oreb', 'dreb'].includes(selectedStat)) return 1;
                                    if (['fgm', 'fga', 'fg3m', 'fg3a', 'ftm', 'fta', 'pf'].includes(selectedStat)) return 1;
                                    if (['fg_pct', 'fg3_pct', 'ft_pct'].includes(selectedStat)) return 0.1;
                                    if (selectedStat === 'min') return 5;
                                    return 1;
                                  })();
                                  const maxTick = Math.ceil(maxValue / tickInterval) * tickInterval + (maxValue % tickInterval === 0 ? tickInterval : 0);
                                  
                                  const ticks = [];
                                  for (let i = 0; i <= maxTick; i += tickInterval) {
                                    ticks.push(i);
                                  }
                                  return ticks;
                                })()}
                              />
                              <Tooltip 
                                contentStyle={{
                                  backgroundColor: themeDark ? '#1e293b' : '#ffffff',
                                  border: `1px solid ${themeDark ? '#475569' : '#d1d5db'}`,
                                  borderRadius: '8px',
                                  color: themeDark ? '#ffffff' : '#1f2937',
                                  fontSize: '12px'
                                }}
                                content={({ active, payload, label }) => {
                                  if (active && payload && payload.length > 0) {
                                    const data = payload[0].payload;
                                    return (
                                      <div style={{
                                        backgroundColor: themeDark ? '#1e293b' : '#ffffff',
                                        border: `1px solid ${themeDark ? '#475569' : '#d1d5db'}`,
                                        borderRadius: '8px',
                                        padding: '12px',
                                        fontSize: '12px',
                                        color: themeDark ? '#ffffff' : '#1f2937',
                                        lineHeight: '1.4'
                                      }}>
                                        <div style={{ marginBottom: '4px', fontWeight: 'bold' }}>
                                          {data.fullDate || label}
                                        </div>
                                        <div style={{ marginBottom: '4px' }}>
                                          {data.value} {selectedStat.toUpperCase()}
                                        </div>
                                        <div style={{ marginBottom: '4px' }}>
                                          vs {data.opponent || 'Unknown'}
                                        </div>
                                        <div style={{ fontWeight: 'bold', color: '#10b981' }}>
                                          {(() => {
                                            const minutes = data.minutes;
                                            if (typeof minutes === 'string' && minutes.includes(':')) {
                                              return `${minutes} MIN`;
                                            } else if (typeof minutes === 'string') {
                                              const minValue = parseFloat(minutes);
                                              return `${Math.round(minValue)} MIN`;
                                            } else if (minutes) {
                                              return `${Math.round(minutes)} MIN`;
                                            }
                                            return '0 MIN';
                                          })()
                                          }
                                        </div>
                                      </div>
                                    );
                                  }
                                  return null;
                                }}
                              />
                              <Bar dataKey="value" radius={[4, 4, 0, 0]} isAnimationActive={false}>
                                {chartData.map((entry, index) => (
                                  <Cell 
                                    key={`cell-${index}`} 
                                    fill={
                                      entry.value === selectedLine ? '#6b7280' : // Grey for exact match (push)
                                      entry.value > selectedLine ? '#10b981' : // Green for over
                                      '#ef4444' // Red for under
                                    }
                                  />
                                ))}
                                <LabelList 
                                  dataKey="value" 
                                  position="top" 
                                  style={{ 
                                    fontSize: '12px', 
                                    fontWeight: 'bold',
                                    fill: themeDark ? '#ffffff' : '#000000'
                                  }}
                                />
                              </Bar>
                              <ReferenceLine 
                                y={selectedLine} 
                                stroke={themeDark ? "#ffffff" : "#000000"} 
                                strokeWidth={2}
                              />
                            </BarChart>
                          </ResponsiveContainer>
                          {/* title overlay */}
                          <div className="absolute bottom-6 right-6">
                            <div className={`px-3 py-1 font-mono text-xs font-medium rounded border ${themeDark ? "bg-slate-800 bg-opacity-90 text-emerald-400 border-slate-600" : "bg-white bg-opacity-90 text-emerald-600 border-slate-300"}`}>{`[${selectedStat.toUpperCase()}] ${selectedTimeFilter.toUpperCase().replace(/LAST/g, 'L').replace(/SEASON/g, 'S')}`}</div>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          {/* right pane - game stats */}
          <div className="w-full lg:w-80 flex-shrink-0 -mt-4">
            <div className={`rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
              <div className={`px-3 py-2 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
                <div className="flex items-center gap-2">
                  <div className={`w-2 h-2 rounded-full ${themeDark ? "bg-cyan-400" : "bg-cyan-500"} animate-pulse`} />
                  <h3 className={`font-semibold text-sm font-mono tracking-wider ${themeDark ? "text-white" : "text-slate-900"}`}>
                    OPPONENT BREAKDOWN
                  </h3>
                  <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                    {selectedTimeFilter.toUpperCase()}
                  </span>
                </div>
              </div>
              
              <div className="p-4 space-y-3">
                {/* Opponent Defensive Stats */}
                <div className="space-y-2">
                  <div className={`text-xs font-mono font-bold uppercase tracking-wider`}>
                    <span className={`${themeDark ? "text-green-400" : "text-green-600"}`}>{opponentTeam}</span>
                    <span className={`${themeDark ? "text-slate-400" : "text-slate-500"}`}> DEFENSIVE RANKS</span>
                  </div>
                  <div className="space-y-1">
                    {/* Points Allowed */}
                    <div className="flex items-center justify-between">
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>PTS ALLOWED</span>
                      <span className={`text-sm font-bold ${getOpponentDefensiveRankColor(getOpponentDefensiveRank(opponentTeam, 'ptsAllowed'))}`}>
                        {getOrdinalSuffix(getOpponentDefensiveRank(opponentTeam, 'ptsAllowed'))}
                      </span>
                    </div>
                    
                    {/* Rebounds Allowed */}
                    <div className="flex items-center justify-between">
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>REB ALLOWED</span>
                      <span className={`text-sm font-bold ${getOpponentDefensiveRankColor(getOpponentDefensiveRank(opponentTeam, 'rebAllowed'))}`}>
                        {getOrdinalSuffix(getOpponentDefensiveRank(opponentTeam, 'rebAllowed'))}
                      </span>
                    </div>
                    
                    {/* Assists Allowed */}
                    <div className="flex items-center justify-between">
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>AST ALLOWED</span>
                      <span className={`text-sm font-bold ${getOpponentDefensiveRankColor(getOpponentDefensiveRank(opponentTeam, 'astAllowed'))}`}>
                        {getOrdinalSuffix(getOpponentDefensiveRank(opponentTeam, 'astAllowed'))}
                      </span>
                    </div>
                    
                    {/* Field Goals Made Allowed */}
                    <div className="flex items-center justify-between">
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>FGM ALLOWED</span>
                      <span className={`text-sm font-bold ${getOpponentDefensiveRankColor(getOpponentDefensiveRank(opponentTeam, 'fgmAllowed'))}`}>
                        {getOrdinalSuffix(getOpponentDefensiveRank(opponentTeam, 'fgmAllowed'))}
                      </span>
                    </div>
                    
                    {/* Field Goals Attempted Allowed */}
                    <div className="flex items-center justify-between">
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>FGA ALLOWED</span>
                      <span className={`text-sm font-bold ${getOpponentDefensiveRankColor(getOpponentDefensiveRank(opponentTeam, 'fgaAllowed'))}`}>
                        {getOrdinalSuffix(getOpponentDefensiveRank(opponentTeam, 'fgaAllowed'))}
                      </span>
                    </div>
                    
                    {/* 3-Pointers Made Allowed */}
                    <div className="flex items-center justify-between">
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>3PM ALLOWED</span>
                      <span className={`text-sm font-bold ${getOpponentDefensiveRankColor(getOpponentDefensiveRank(opponentTeam, 'fg3mAllowed'))}`}>
                        {getOrdinalSuffix(getOpponentDefensiveRank(opponentTeam, 'fg3mAllowed'))}
                      </span>
                    </div>
                    
                    {/* 3-Pointers Attempted Allowed */}
                    <div className="flex items-center justify-between">
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>3PA ALLOWED</span>
                      <span className={`text-sm font-bold ${getOpponentDefensiveRankColor(getOpponentDefensiveRank(opponentTeam, 'fg3aAllowed'))}`}>
                        {getOrdinalSuffix(getOpponentDefensiveRank(opponentTeam, 'fg3aAllowed'))}
                      </span>
                    </div>
                    
                    {/* Steals Allowed */}
                    <div className="flex items-center justify-between">
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>STL ALLOWED</span>
                      <span className={`text-sm font-bold ${getOpponentDefensiveRankColor(getOpponentDefensiveRank(opponentTeam, 'stlAllowed'))}`}>
                        {getOrdinalSuffix(getOpponentDefensiveRank(opponentTeam, 'stlAllowed'))}
                      </span>
                    </div>
                    
                    {/* Blocks Allowed */}
                    <div className="flex items-center justify-between">
                      <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"}`}>BLK ALLOWED</span>
                      <span className={`text-sm font-bold ${getOpponentDefensiveRankColor(getOpponentDefensiveRank(opponentTeam, 'blkAllowed'))}`}>
                        {getOrdinalSuffix(getOpponentDefensiveRank(opponentTeam, 'blkAllowed'))}
                      </span>
                    </div>
                  </div>
                </div>
                
                {/* Color Legend and Season Info */}
                <div className={`mt-4 pt-3 border-t ${themeDark ? "border-slate-700" : "border-slate-200"}`}>
                  <div className="space-y-2">
                    {/* Color Legend */}
                    <div className="flex items-center justify-center gap-4 text-xs font-mono">
                      <div className="flex items-center gap-1">
                        <div className="w-2 h-2 rounded-full bg-green-500"></div>
                        <span className={`${themeDark ? "text-slate-400" : "text-slate-500"}`}>GOOD FOR OVERS</span>
                      </div>
                      <div className="flex items-center gap-1">
                        <div className="w-2 h-2 rounded-full bg-red-500"></div>
                        <span className={`${themeDark ? "text-slate-400" : "text-slate-500"}`}>BAD FOR OVERS</span>
                      </div>
                    </div>
                    
                    {/* Season Info */}
                    <div className="text-center">
                      <div className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                        2024-25 STATS ‚Ä¢ UPDATED UNTIL NEW SEASON
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            {/* Two boxes under opponent breakdown */}
            <div className="mt-4 space-y-3">
              {/* Box 1 - Bookmaker Value Analysis */}
              <div className={`rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
                <div className={`px-3 py-2 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <div className={`w-2 h-2 rounded-full ${themeDark ? "bg-yellow-400" : "bg-yellow-500"} animate-pulse`} />
                      <h4 className={`font-semibold text-xs font-mono tracking-wider ${themeDark ? "text-white" : "text-slate-900"}`}>
                        VALUE ANALYSIS
                      </h4>
                    </div>
                    {/* Bookmaker Selector */}
                    <select
                      value={selectedBookmaker}
                      onChange={(e) => setSelectedBookmaker(e.target.value)}
                      className={`px-2 py-1 text-xs font-mono rounded border ${
                        themeDark 
                          ? "bg-slate-800 border-slate-600 text-white" 
                          : "bg-white border-slate-300 text-black"
                      } focus:outline-none focus:ring-1 focus:ring-blue-500`}
                    >
                      <option value="fanduel">FANDUEL</option>
                      <option value="draftkings">DRAFTKINGS</option>
                      <option value="betmgm">BETMGM</option>
                      <option value="fanatics">FANATICS</option>
                    </select>
                  </div>
                </div>
                <div className="px-2.5 py-2">
                  <div className="space-y-2">
                    {(() => {
                      // Get bookmaker-specific odds and line
                      const getBookmakerData = (bookmaker: string) => {
                        switch(bookmaker) {
                          case 'fanduel':
                            return {
                              line: (Math.floor(selectedLine) + 0.5).toFixed(1),
                              overOdds: -108,
                              underOdds: -112
                            };
                          case 'draftkings':
                            return {
                              line: (Math.floor(selectedLine) - 0.5).toFixed(1),
                              overOdds: -110,
                              underOdds: -110
                            };
                          case 'betmgm':
                            return {
                              line: (Math.floor(selectedLine) + 1.5).toFixed(1),
                              overOdds: -105,
                              underOdds: -115
                            };
                          case 'fanatics':
                            return {
                              line: (Math.floor(selectedLine) + 0.5).toFixed(1),
                              overOdds: -112,
                              underOdds: -108
                            };
                          default:
                            return {
                              line: selectedLine.toFixed(1),
                              overOdds: -110,
                              underOdds: -110
                            };
                        }
                      };
                      
                      const bookmakerData = getBookmakerData(selectedBookmaker);
                      const bookmakerLine = parseFloat(bookmakerData.line);
                      
                      // Calculate implied probability for OVER bet
                      const overOdds = bookmakerData.overOdds;
                      const impliedProbOver = overOdds < 0 
                        ? (Math.abs(overOdds) / (Math.abs(overOdds) + 100)) * 100
                        : (100 / (overOdds + 100)) * 100;
                      
                      // Calculate actual hit rate from recent games for this line
                      const recentGames = chartData.slice(-10); // Last 10 games
                      const hitsOver = recentGames.filter(game => game.value > bookmakerLine).length;
                      const actualHitRate = recentGames.length > 0 ? (hitsOver / recentGames.length) * 100 : 0;
                      
                      // Calculate expected value
                      const expectedValue = (actualHitRate / 100) - (impliedProbOver / 100);
                      const valuePercentage = expectedValue * 100;
                      
                      return (
                        <>
                          <div className="flex items-center justify-between">
                            <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-600"}`}>LINE</span>
                            <span className={`text-sm font-bold ${themeDark ? "text-white" : "text-black"}`}>O/U {bookmakerData.line}</span>
                          </div>
                          <div className="flex items-center justify-between">
                            <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-600"}`}>IMPLIED PROB</span>
                            <span className={`text-sm font-bold ${themeDark ? "text-white" : "text-black"}`}>{impliedProbOver.toFixed(1)}%</span>
                          </div>
                          <div className="flex items-center justify-between">
                            <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-600"}`}>HIT RATE</span>
                            <span className={`text-sm font-bold ${themeDark ? "text-white" : "text-black"}`}>{actualHitRate.toFixed(1)}%</span>
                          </div>
                          <div className="flex items-center justify-between">
                            <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-600"}`}>EDGE</span>
                            <span className={`text-sm font-bold ${
                              valuePercentage > 0 
                                ? (themeDark ? "text-green-400" : "text-green-500")
                                : valuePercentage < 0
                                ? (themeDark ? "text-red-400" : "text-red-500")
                                : (themeDark ? "text-slate-400" : "text-slate-500")
                            }`}>
                              {valuePercentage > 0 ? `+${valuePercentage.toFixed(1)}%` : `${valuePercentage.toFixed(1)}%`}
                            </span>
                          </div>
                          <div className="flex items-center justify-between">
                            <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-600"}`}>ODDS</span>
                            <div className="flex items-center gap-2">
                              <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-green-900 text-green-300" : "bg-green-100 text-green-700"}`}>
                                Over ({(() => {
                                  if (oddsFormat === 'decimal') {
                                    const decimal = overOdds < 0 
                                      ? (100 / Math.abs(overOdds) + 1).toFixed(2)
                                      : (overOdds / 100 + 1).toFixed(2);
                                    return decimal;
                                  } else {
                                    return overOdds;
                                  }
                                })()})
                              </span>
                              <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-red-900 text-red-300" : "bg-red-100 text-red-700"}`}>
                                Under ({(() => {
                                  const underOdds = bookmakerData.underOdds;
                                  if (oddsFormat === 'decimal') {
                                    const decimal = underOdds < 0 
                                      ? (100 / Math.abs(underOdds) + 1).toFixed(2)
                                      : (underOdds / 100 + 1).toFixed(2);
                                    return decimal;
                                  } else {
                                    return underOdds;
                                  }
                                })()})
                              </span>
                            </div>
                          </div>
                        </>
                      );
                    })()}
                  </div>
                </div>
              </div>
              
              {/* Box 2 - Live Bookmaker Odds */}
              <div className={`rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
                <div className={`px-3 py-2 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <div className={`w-2 h-2 rounded-full ${themeDark ? "bg-green-400" : "bg-green-500"} animate-pulse`} />
                      <h4 className={`font-semibold text-xs font-mono tracking-wider ${themeDark ? "text-white" : "text-slate-900"}`}>
                        LIVE BOOKMAKER ODDS
                      </h4>
                      <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                        {selectedStat.toUpperCase()} O/U
                      </span>
                    </div>
                    {/* Odds Format Selector */}
                    <select
                      value={oddsFormat}
                      onChange={(e) => handleOddsFormatChange(e.target.value)}
                      className={`px-2 py-1 text-xs font-mono rounded border ${
                        themeDark 
                          ? "bg-slate-800 border-slate-600 text-white" 
                          : "bg-white border-slate-300 text-black"
                      } focus:outline-none focus:ring-1 focus:ring-blue-500`}
                    >
                      <option value="american">AMERICAN</option>
                      <option value="decimal">DECIMAL</option>
                    </select>
                  </div>
                </div>
                <div className="px-2 py-2">
                  <div className="space-y-1">
                    {(() => {
                      // Function to convert American odds to Decimal odds
                      const convertOdds = (americanOdds: number) => {
                        if (oddsFormat === 'decimal') {
                          if (americanOdds < 0) {
                            return (100 / Math.abs(americanOdds) + 1).toFixed(2);
                          } else {
                            return (americanOdds / 100 + 1).toFixed(2);
                          }
                        } else {
                          return americanOdds.toString();
                        }
                      };
                      
                      const formatOdds = (americanOdds: number) => {
                        if (oddsFormat === 'decimal') {
                          return convertOdds(americanOdds);
                        } else {
                          return `(${americanOdds})`;
                        }
                      };
                      
                      return (
                        <>
                    {/* FanDuel */}
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <img 
                          src="/logos/fanduel.png" 
                          alt="FanDuel" 
                          className="w-6 h-6 object-contain"
                          onError={(e) => {
                            const target = e.target as HTMLImageElement;
                            target.style.display = 'none';
                            target.insertAdjacentHTML('afterend', `<div class="w-6 h-6 rounded bg-blue-600 flex items-center justify-center text-white text-xs font-bold">FD</div>`);
                          }}
                        />
                        <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"} font-medium`}>FANDUEL</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-green-900 text-green-300" : "bg-green-100 text-green-700"}`}>
                          O {(Math.floor(selectedLine) + 0.5).toFixed(1)} {formatOdds(-108)}
                        </span>
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-red-900 text-red-300" : "bg-red-100 text-red-700"}`}>
                          U {(Math.floor(selectedLine) + 0.5).toFixed(1)} {formatOdds(-112)}
                        </span>
                      </div>
                    </div>
                    
                    {/* DraftKings */}
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <img 
                          src="/logos/draftkings.png" 
                          alt="DraftKings" 
                          className="w-6 h-6 object-contain"
                          onError={(e) => {
                            const target = e.target as HTMLImageElement;
                            target.style.display = 'none';
                            target.insertAdjacentHTML('afterend', `<div class="w-6 h-6 rounded bg-green-600 flex items-center justify-center text-white text-xs font-bold">DK</div>`);
                          }}
                        />
                        <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"} font-medium`}>DRAFTKINGS</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-green-900 text-green-300" : "bg-green-100 text-green-700"}`}>
                          O {(Math.floor(selectedLine) - 0.5).toFixed(1)} {formatOdds(-110)}
                        </span>
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-red-900 text-red-300" : "bg-red-100 text-red-700"}`}>
                          U {(Math.floor(selectedLine) - 0.5).toFixed(1)} {formatOdds(-110)}
                        </span>
                      </div>
                    </div>
                    
                    {/* BetMGM */}
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <img 
                          src="/logos/betmgm.png" 
                          alt="BetMGM" 
                          className="w-6 h-6 object-contain"
                          onError={(e) => {
                            const target = e.target as HTMLImageElement;
                            target.style.display = 'none';
                            target.insertAdjacentHTML('afterend', `<div class="w-6 h-6 rounded bg-yellow-600 flex items-center justify-center text-white text-xs font-bold">MGM</div>`);
                          }}
                        />
                        <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"} font-medium`}>BETMGM</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-green-900 text-green-300" : "bg-green-100 text-green-700"}`}>
                          O {(Math.floor(selectedLine) + 1.5).toFixed(1)} {formatOdds(-105)}
                        </span>
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-red-900 text-red-300" : "bg-red-100 text-red-700"}`}>
                          U {(Math.floor(selectedLine) + 1.5).toFixed(1)} {formatOdds(-115)}
                        </span>
                      </div>
                    </div>
                    
                    {/* Fanatics */}
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <img 
                          src="/logos/fanatics.svg" 
                          alt="Fanatics" 
                          className="w-6 h-6 object-contain"
                          onError={(e) => {
                            const target = e.target as HTMLImageElement;
                            target.style.display = 'none';
                            target.insertAdjacentHTML('afterend', `<div class="w-6 h-6 rounded bg-red-600 flex items-center justify-center text-white text-xs font-bold">FAN</div>`);
                          }}
                        />
                        <span className={`text-xs font-mono ${themeDark ? "text-white" : "text-black"} font-medium`}>FANATICS</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-green-900 text-green-300" : "bg-green-100 text-green-700"}`}>
                          O {(Math.floor(selectedLine) + 0.5).toFixed(1)} {formatOdds(-112)}
                        </span>
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-red-900 text-red-300" : "bg-red-100 text-red-700"}`}>
                          U {(Math.floor(selectedLine) + 0.5).toFixed(1)} {formatOdds(-108)}
                        </span>
                      </div>
                    </div>
                        </>
                      );
                    })()}
                    
                    {/* Best Line Summary */}
                    <div className={`mt-3 pt-2 border-t ${themeDark ? "border-slate-700" : "border-slate-200"}`}>
                      <div className="flex items-center justify-between">
                        <span className={`text-xs font-mono font-bold ${themeDark ? "text-green-400" : "text-green-600"}`}>BEST OVER</span>
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-green-900 text-green-300" : "bg-green-100 text-green-700"}`}>
                          DK O{(Math.floor(selectedLine) - 0.5).toFixed(1)} (-110)
                        </span>
                      </div>
                      <div className="flex items-center justify-between mt-1">
                        <span className={`text-xs font-mono font-bold ${themeDark ? "text-green-400" : "text-green-600"}`}>BEST UNDER</span>
                        <span className={`text-xs font-bold px-2 py-0.5 rounded ${themeDark ? "bg-green-900 text-green-300" : "bg-green-100 text-green-700"}`}>
                          MGM U{(Math.floor(selectedLine) + 1.5).toFixed(1)} (-115)
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        {/* Two-column layout: Depth Chart (left) and Stats (right) */}
        <div className="mt-6 grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Left Column - Team Roster/Depth Chart Section */}
          <div className={`rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
          <div className={`px-4 py-3 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className={`w-2 h-2 rounded-full ${themeDark ? "bg-purple-400" : "bg-purple-500"} animate-pulse`} />
                <div>
                  <h3 className={`font-semibold text-lg font-mono tracking-wide ${themeDark ? "text-white" : "text-slate-900"}`}>
                    DEPTH CHART
                  </h3>
                  <p className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                    {currentTeamName} ‚Ä¢ Current Season
                  </p>
                </div>
              </div>
            </div>
          </div>
          
          {/* Always show depth chart - removed conditional rendering */}
          {(
            <div className="p-4">
              {loadingRoster ? (
                <div className="flex items-center justify-center py-8">
                  <div className="animate-spin w-8 h-8 border-2 border-purple-500 border-t-transparent rounded-full" />
                  <span className={`ml-3 text-sm ${themeDark ? "text-slate-300" : "text-slate-700"}`}>Loading roster...</span>
                </div>
              ) : teamRoster.length > 0 ? (
                (() => {
                  const depthChart = createDepthChart(teamRoster);
                  
                  // If no real depth chart data available, show message
                  if (!depthChart) {
                    return (
                      <div className={`text-center py-12 ${themeDark ? "text-slate-400" : "text-slate-600"}`}>
                        <div className="text-lg font-bold mb-2">No Live Roster Available</div>
                        <div className="text-sm mb-4">Unable to load current depth chart data from ESPN</div>
                        <div className={`text-xs ${themeDark ? "text-slate-500" : "text-slate-400"}`}>
                          {loadingDepthChart ? 'Loading depth chart...' : 'Depth chart data not available for this team'}
                        </div>
                      </div>
                    );
                  }
                  
                  const maxDepth = Math.max(
                    depthChart.PG.length,
                    depthChart.SG.length,
                    depthChart.SF.length,
                    depthChart.PF.length,
                    depthChart.C.length
                  );
                  
                  const positions = [
                    { key: 'PG', label: 'POINT GUARD' },
                    { key: 'SG', label: 'SHOOTING GUARD' },
                    { key: 'SF', label: 'SMALL FORWARD' },
                    { key: 'PF', label: 'POWER FORWARD' },
                    { key: 'C', label: 'CENTER' }
                  ];
                  
                  return (
                    <div className="overflow-x-auto">
                      <div className="min-w-full">
                        {/* Depth Headers (top row) */}
                        <div className="grid gap-3 mb-4" style={{ gridTemplateColumns: `150px repeat(${maxDepth}, minmax(120px, 1fr))` }}>
                          <div></div> {/* Empty corner cell */}
                          {Array.from({ length: maxDepth }, (_, index) => (
                            <div key={index} className={`text-center font-bold py-2 rounded text-xs ${themeDark ? "bg-slate-700 text-purple-300" : "bg-slate-200 text-purple-700"}`}>
                              {index === 0 ? 'STARTER' : index === 1 ? '2ND' : index === 2 ? '3RD' : index === 3 ? '4TH' : `${index + 1}TH`}
                            </div>
                          ))}
                        </div>
                        
                        {/* Position Rows */}
                        {positions.map((position) => (
                          <div key={position.key} className="grid gap-3 mb-2" style={{ gridTemplateColumns: `150px repeat(${maxDepth}, minmax(120px, 1fr))` }}>
                            {/* Position Label */}
                            <div className={`flex items-center justify-center font-bold py-2 px-3 rounded text-xs ${themeDark ? "bg-slate-700 text-purple-300" : "bg-slate-200 text-purple-700"}`}>
                              {position.label}
                            </div>
                            
                            {/* Players for this position across depth */}
                            {Array.from({ length: maxDepth }, (_, depthIndex) => {
                              const player = depthChart[position.key as keyof typeof depthChart][depthIndex];
                              return (
                                <div key={depthIndex} className="flex justify-center">
                                  {player ? (
                                    <button
                                      onClick={() => {
                                        const playerName = player.name;
                                        console.log(`üîÑ Switching to player: ${playerName}`);
                                        setSelectedPlayer(playerName);
                                        const encodedPlayer = encodeURIComponent(playerName);
                                        router.push(`${window.location.pathname}?player=${encodedPlayer}`);
                                      }}
                                      className={`relative w-full p-2 text-center rounded transition-all border text-xs ${
                                        player.name === selectedPlayer
                                          ? themeDark
                                            ? 'bg-purple-900/70 border-purple-400 text-purple-200'
                                            : 'bg-purple-50 border-purple-400 text-purple-900'
                                          : themeDark
                                          ? 'bg-slate-800/50 text-slate-300 hover:bg-slate-700 border-slate-600'
                                          : 'bg-white text-slate-800 hover:bg-slate-50 border-slate-200'
                                      }`}
                                    >
                                      {/* Injury Status Badge */}
                                      {(() => {
                                        const status = player.status?.toLowerCase();
                                        if (status === 'day to day' || status === 'day-to-day' || status === 'questionable') {
                                          return (
                                            <div className="absolute -top-1 -right-1 bg-yellow-500 text-white text-xs font-bold px-1.5 py-0.5 rounded-full leading-none">
                                              DD
                                            </div>
                                          );
                                        } else if (status === 'out' || status === 'injured' || status === 'inactive') {
                                          return (
                                            <div className="absolute -top-1 -right-1 bg-red-500 text-white text-xs font-bold px-1.5 py-0.5 rounded-full leading-none">
                                              OUT
                                            </div>
                                          );
                                        } else if (status === 'probable') {
                                          return (
                                            <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs font-bold px-1.5 py-0.5 rounded-full leading-none">
                                              ‚úì
                                            </div>
                                          );
                                        }
                                        return null;
                                      })()} 
                                      
                                      <div className="font-semibold mb-1">
                                        {player.name}
                                      </div>
                                      <div className={`text-xs flex items-center justify-center gap-2 ${
                                        player.status?.toLowerCase() === 'out' || 
                                        player.status?.toLowerCase() === 'injured' || 
                                        player.status?.toLowerCase() === 'inactive'
                                          ? 'opacity-50' : 'opacity-70'
                                      }`}>
                                        <span>#{player.jersey}</span>
                                        {player.position && (
                                          <span className={`text-xs px-1 rounded ${
                                            themeDark ? 'bg-slate-700 text-slate-400' : 'bg-slate-100 text-slate-600'
                                          }`}>
                                            {player.position}
                                          </span>
                                        )}
                                      </div>
                                    </button>
                                  ) : (
                                    <div className={`w-full p-2 rounded border-2 border-dashed ${
                                      themeDark ? 'border-slate-600' : 'border-slate-300'
                                    }`}></div>
                                  )}
                                </div>
                              );
                            })}
                          </div>
                        ))}
                      </div>
                    </div>
                  );
                })()
              ) : (
                <div className={`text-center py-8 ${themeDark ? "text-slate-400" : "text-slate-600"}`}>
                  <div className="text-lg font-bold mb-2">No roster available</div>
                  <div className="text-sm">Unable to load roster data for {selectedTeam}</div>
                </div>
              )}
            </div>
          )}
          </div>
          
          {/* Right Column - Stats Sections */}
          <div className="space-y-2">
            
            {/* Section 1: Player Line Movement */}
            <div className={`rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
              <div className={`px-2 py-1.5 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
                <div className="flex items-center gap-1.5">
                  <div className={`w-1 h-1 rounded-full ${themeDark ? "bg-green-400" : "bg-green-500"}`} />
                  <div>
                    <h3 className={`font-semibold text-xs font-mono ${themeDark ? "text-white" : "text-slate-900"}`}>
                      LINE MOVEMENT
                    </h3>
                    <p className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                      {selectedPlayer} ‚Ä¢ {selectedStat.toUpperCase()}
                    </p>
                  </div>
                </div>
              </div>
              
              <div className="p-2">
                <PlayerLineMovement selectedPlayer={selectedPlayer} />
              </div>
            </div>
            
            {/* Section 2: Team Matchup & Odds */}
            <div className={`rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
              <div className={`px-2 py-1.5 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
                <div className="flex items-center gap-1.5">
                  <div className={`w-1 h-1 rounded-full ${themeDark ? "bg-blue-400" : "bg-blue-500"}`} />
                  <h3 className={`font-semibold text-xs font-mono ${themeDark ? "text-white" : "text-slate-900"}`}>
                    GAME ODDS
                  </h3>
                </div>
              </div>
              
              <div className="p-2">
                <div className="space-y-1.5">
                  {/* Team Matchup */}
                  <TeamMatchupOdds 
                    currentTeamName={currentTeamName} 
                    opponentTeamName={opponentTeamName}
                    themeDark={themeDark} 
                  />
                  
                  {/* Total O/U */}
                  <div className="grid grid-cols-1 gap-1 text-xs">
                    <div className={`p-1 rounded text-center ${themeDark ? "bg-slate-800" : "bg-slate-100"}`}>
                      <GameTotalOdds />
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            {/* Section 3: Blank Box for New Feature */}
            <div className={`rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
              <div className={`px-2 py-1.5 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
                <div className="flex items-center gap-1.5">
                  <div className={`w-1 h-1 rounded-full ${themeDark ? "bg-purple-400" : "bg-purple-500"}`} />
                  <h3 className={`font-semibold text-xs font-mono ${themeDark ? "text-white" : "text-slate-900"}`}>
                    BEST ODDS
                  </h3>
                </div>
              </div>
              
              <div className="p-2">
                <BookmakerComparison 
                  selectedPlayer={selectedPlayer}
                  currentTeamName={currentTeamName}
                  opponentTeamName={opponentTeamName}
                  themeDark={themeDark}
                />
              </div>
            </div>
            
          </div>
        </div>
        
        {/* Box Score Section */}
        <div className={`mt-6 rounded-lg border ${themeDark ? "bg-slate-900/80 border-slate-700" : "bg-white border-slate-200"}`}>
          <div className={`px-4 py-3 border-b ${themeDark ? "border-slate-700 bg-slate-800/50" : "border-slate-200 bg-slate-50"}`}>
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className={`w-2 h-2 rounded-full ${themeDark ? "bg-orange-400" : "bg-orange-500"} animate-pulse`} />
                <div>
                  <h3 className={`font-semibold text-lg font-mono tracking-wide ${themeDark ? "text-white" : "text-slate-900"}`}>
                    RECENT GAMES
                  </h3>
                  <p className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                    {selectedTimeFilter.toUpperCase()} Box Scores ‚Ä¢ {selectedStat.toUpperCase()} Focus
                  </p>
                </div>
              </div>
              
              {/* Pagination */}
              <div className="flex items-center gap-2">
                <button
                  onClick={() => setBoxScorePage(Math.max(0, boxScorePage - 1))}
                  disabled={boxScorePage === 0}
                  className={`px-3 py-1 rounded text-xs font-mono transition-all ${
                    boxScorePage === 0
                      ? (themeDark ? "bg-slate-800 text-slate-600 cursor-not-allowed" : "bg-slate-100 text-slate-400 cursor-not-allowed")
                      : (themeDark ? "bg-slate-700 text-white hover:bg-slate-600" : "bg-slate-200 text-black hover:bg-slate-300")
                  }`}
                >
                  PREV
                </button>
                <span className={`text-xs font-mono ${themeDark ? "text-slate-400" : "text-slate-500"}`}>
                  {boxScorePage + 1} / {Math.ceil(filteredRows.length / 10)}
                </span>
                <button
                  onClick={() => setBoxScorePage(Math.min(Math.ceil(filteredRows.length / 10) - 1, boxScorePage + 1))}
                  disabled={boxScorePage >= Math.ceil(filteredRows.length / 10) - 1}
                  className={`px-3 py-1 rounded text-xs font-mono transition-all ${
                    boxScorePage >= Math.ceil(filteredRows.length / 5) - 1
                      ? (themeDark ? "bg-slate-800 text-slate-600 cursor-not-allowed" : "bg-slate-100 text-slate-400 cursor-not-allowed")
                      : (themeDark ? "bg-slate-700 text-white hover:bg-slate-600" : "bg-slate-200 text-black hover:bg-slate-300")
                  }`}
                >
                  NEXT
                </button>
              </div>
            </div>
          </div>
          
          <div className="overflow-x-auto">
            {filteredRows.length === 0 ? (
              <div className={`text-center py-8 ${themeDark ? 'text-slate-400' : 'text-slate-600'}`}>
                <div className="text-lg font-bold mb-2">No Game Data</div>
                <div className="text-sm">No games found for the selected timeframe</div>
              </div>
            ) : (
              <table className={`w-full text-sm ${themeDark ? "text-white" : "text-black"}`}>
                {/* Table Header */}
                <thead className={`${themeDark ? "bg-slate-800/50" : "bg-slate-100"}`}>
                  <tr className={`border-b ${themeDark ? "border-slate-700" : "border-slate-200"}`}>
                    <th className="px-3 py-2 text-left font-mono font-bold text-xs uppercase tracking-wider">Date</th>
                    <th className="px-3 py-2 text-left font-mono font-bold text-xs uppercase tracking-wider">Opponent</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider w-16">H/A</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider w-20">Result</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">Min</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">Pts</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">Reb</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">Ast</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">Stl</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">Blk</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">TO</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">PF</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">FG</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">FG%</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">3PM</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">3P%</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">FT</th>
                    <th className="px-3 py-2 text-center font-mono font-bold text-xs uppercase tracking-wider">FT%</th>
                  </tr>
                </thead>
                
                {/* Table Body */}
                <tbody>
                  {[...filteredRows].reverse().slice(boxScorePage * 10, (boxScorePage + 1) * 10).map((row, index) => {
                    const globalIndex = boxScorePage * 10 + index;
                    const statValue = pickStat(row, selectedStat);
                    const overUnder = statValue > selectedLine ? 'OVER' : statValue === selectedLine ? 'PUSH' : 'UNDER';
                    const overUnderColor = 
                      overUnder === 'OVER' ? 'text-green-500' :
                      overUnder === 'PUSH' ? 'text-gray-500' :
                      'text-red-500';
                    
                    // Get team abbreviation for this specific game
                    const playerTeamAtTime = row.team?.abbreviation || getPlayerTeam(selectedPlayer);
                    const opponent = getOpponentFromGame(row.game, playerTeamAtTime);
                    
                    // Direct approach: determine if player team is home based on game structure
                    // We know playerTeamAtTime and opponent are correct from above
                    // We need to figure out which position (home/visitor) the player team is in
                    
                    const homeScore = row.game.home_team_score || 0;
                    const visitorScore = row.game.visitor_team_score || 0;
                    
                    // Use the comprehensive team ID mapping function already defined above
                    // Reverse lookup: find team ID from abbreviation
                    const getTeamIdByAbbreviation = (abbr: string): number | null => {
                      // Use the existing getTeamAbbreviationById function in reverse
                      const teamMap: Record<string, number> = {
                        'ATL': 1, 'BOS': 2, 'BKN': 3, 'CHA': 4, 'CHI': 5,
                        'CLE': 6, 'DAL': 7, 'DEN': 8, 'DET': 9, 'GSW': 10,
                        'HOU': 11, 'IND': 12, 'LAC': 13, 'LAL': 14, 'MEM': 15,
                        'MIA': 16, 'MIL': 17, 'MIN': 18, 'NOP': 19, 'NYK': 20,
                        'OKC': 21, 'ORL': 22, 'PHI': 23, 'PHX': 24, 'POR': 25,
                        'SAC': 26, 'SAS': 27, 'TOR': 28, 'UTA': 29, 'WAS': 30
                      };
                      return teamMap[abbr] || null;
                    };
                    
                    const playerTeamId = getTeamIdByAbbreviation(playerTeamAtTime);
                    const isHome = row.game.home_team_id === playerTeamId;
                    
                    // Determine win/loss
                    let isWin, playerScore, opponentScore;
                    if (isHome) {
                      // Player's team is home
                      isWin = homeScore > visitorScore;
                      playerScore = homeScore;
                      opponentScore = visitorScore;
                    } else {
                      // Player's team is visitor/away
                      isWin = visitorScore > homeScore;
                      playerScore = visitorScore;
                      opponentScore = homeScore;
                    }
                    
                    // Calculate percentages
                    const fgPct = (row.fga && row.fga > 0) ? ((row.fgm || 0) / row.fga * 100).toFixed(1) : '0.0';
                    const fg3Pct = (row.fg3a && row.fg3a > 0) ? ((row.fg3m || 0) / row.fg3a * 100).toFixed(1) : '0.0';
                    const ftPct = (row.fta && row.fta > 0) ? ((row.ftm || 0) / row.fta * 100).toFixed(1) : '0.0';
                    
                    return (
                      <tr 
                        key={row.game.id}
                        className={`border-b transition-colors ${
                          themeDark ? "border-slate-700 hover:bg-slate-800/30" : "border-slate-200 hover:bg-slate-50"
                        }`}
                      >
                        {/* Date */}
                        <td className="px-3 py-3 font-mono text-xs">
                          {formatEST(row.game.date).replace(/,.*/, '')}
                        </td>
                        
                        {/* Opponent */}
                        <td className="pl-8 pr-3 py-3 text-left font-mono text-xs font-bold">
                          <div className="flex items-center gap-2">
                            <img 
                              src={`https://a.espncdn.com/i/teamlogos/nba/500/${getESPNLogoName(opponent)}.png`}
                              alt={`${opponent} logo`}
                              className="w-4 h-4 object-contain"
                              onError={(e) => {
                                const target = e.target as HTMLImageElement;
                                target.src = `https://cdn.espn.com/combiner/i?img=/i/teamlogos/nba/500/${getESPNLogoName(opponent)}.png&h=16&w=16`;
                              }}
                            />
                            {opponent}
                          </div>
                        </td>
                        
                        {/* Home/Away */}
                        <td className="px-3 py-3 text-center font-mono text-xs font-bold">
                          <span className={`px-1 py-0.5 rounded text-xs ${
                            isHome 
                              ? (themeDark ? 'bg-blue-900 text-blue-300' : 'bg-blue-100 text-blue-700')
                              : (themeDark ? 'bg-orange-900 text-orange-300' : 'bg-orange-100 text-orange-700')
                          }`}>
                            {isHome ? 'H' : 'A'}
                          </span>
                        </td>
                        
                        {/* Result */}
                        <td className="px-3 py-3 text-center font-mono text-xs font-bold">
                          <div className="flex items-center justify-center gap-1">
                            <span className={isWin ? 'text-green-500' : 'text-red-500'}>
                              {isWin ? 'W' : 'L'}
                            </span>
                            <span className={`text-xs ${themeDark ? 'text-slate-400' : 'text-slate-500'}`}>
                              {playerScore}-{opponentScore}
                            </span>
                          </div>
                        </td>
                        
                        {/* Minutes */}
                        <td className="px-3 py-3 text-center font-mono text-xs">
                          {(() => {
                            const minutes = row.min;
                            if (typeof minutes === 'string' && minutes.includes(':')) {
                              return minutes;
                            } else if (typeof minutes === 'string') {
                              const minValue = parseFloat(minutes);
                              const mins = Math.floor(minValue);
                              const secs = Math.round((minValue - mins) * 60);
                              return `${mins}:${secs.toString().padStart(2, '0')}`;
                            } else if (minutes) {
                              const mins = Math.floor(minutes);
                              const secs = Math.round((minutes - mins) * 60);
                              return `${mins}:${secs.toString().padStart(2, '0')}`;
                            }
                            return '0:00';
                          })()}
                        </td>
                        
                        {/* Points */}
                        <td className="px-3 py-3 text-center font-mono font-bold">
                          {row.pts || 0}
                        </td>
                        
                        {/* Rebounds */}
                        <td className="px-3 py-3 text-center font-mono font-bold">
                          {row.reb || 0}
                        </td>
                        
                        {/* Assists */}
                        <td className="px-3 py-3 text-center font-mono font-bold">
                          {row.ast || 0}
                        </td>
                        
                        {/* Steals */}
                        <td className="px-3 py-3 text-center font-mono">
                          {row.stl || 0}
                        </td>
                        
                        {/* Blocks */}
                        <td className="px-3 py-3 text-center font-mono">
                          {row.blk || 0}
                        </td>
                        
                        {/* Turnovers */}
                        <td className="px-3 py-3 text-center font-mono">
                          {row.turnover || 0}
                        </td>
                        
                        {/* Personal Fouls */}
                        <td className="px-3 py-3 text-center font-mono">
                          {row.pf || 0}
                        </td>
                        
                        {/* Field Goals */}
                        <td className="px-3 py-3 text-center font-mono text-xs">
                          {row.fgm || 0}-{row.fga || 0}
                        </td>
                        
                        {/* Field Goal % */}
                        <td className="px-3 py-3 text-center font-mono text-xs">
                          {fgPct}%
                        </td>
                        
                        {/* 3-Point Made */}
                        <td className="px-3 py-3 text-center font-mono text-xs">
                          {row.fg3m || 0}-{row.fg3a || 0}
                        </td>
                        
                        {/* 3-Point % */}
                        <td className="px-3 py-3 text-center font-mono text-xs">
                          {fg3Pct}%
                        </td>
                        
                        {/* Free Throws */}
                        <td className="px-3 py-3 text-center font-mono text-xs">
                          {row.ftm || 0}-{row.fta || 0}
                        </td>
                        
                        {/* Free Throw % */}
                        <td className="px-3 py-3 text-center font-mono text-xs">
                          {ftPct}%
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            )}
          </div>
        </div>
      </div>
      
    </div>
  );
}

// Wrap component in error boundary
export default function ResearchDashboard() {
  return (
    <ErrorBoundary>
      <ResearchDashboardComponent />
    </ErrorBoundary>
  );
}
